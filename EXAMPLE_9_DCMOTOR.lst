CCS PCH C Compiler, Version 5.101, 43599               07-Mar-23 15:50

               Filename:   C:\TTVXL\TTVXL\Thuc Hanh\EXAMPLE_9_DCMOTOR.lst

               ROM used:   7464 bytes (23%)
                           Largest free fragment is 25304
               RAM used:   1095 (53%) at main() level
                           1147 (56%) worst case
               Stack used: 6 locations
               Stack size: 31

*
0000:  GOTO   1B38
.................... /************************************ Yeu cau ****************************************************************
....................  1. Nhan phim BT0 de tang toc dong co theo 10 cap
....................  2. Nhan phim BT1 de giam toc dong co theo 10 cap
....................  3. Nhan phim BT2 de dao chieu quay dong co
....................  4. Nhan phim BT3 de dung dong co
....................  5. Do toc do dong co theo don vi vong/phut (RPM) 
....................  6. Hien thi cac thong tin: cap toc do, toc do dong co va chieu quay cua dong co tren GLCD
....................  
.................... ********************************* Cac lenh lien quan *********************************************************
.................... 1. De dieu khien toc do dong co ta viet lenh:
....................                ----------------------------------------------
....................                          dcmotor.duty = dt;
....................                          dcmotor_control();
....................                ----------------------------------------------
....................    .dt la gia tri tu 0(khong quay) den 1000(nhanh nhat)
.................... 2. De dao chieu quay cua dong co ta viet lenh:
....................                ----------------------------------------------
....................                          dcmotor.direct = dr;
....................                          dcmotor_control();
....................                ----------------------------------------------
....................    . dr = dcmotor_direct_forward hoac 1 => de dong co quay thuan    
....................    . dr = dcmotor_direct_reverse hoac 0 => de dong co quay nghich                 
.................... 3. De do toc do dong co ta thuc hien theo mau sau trong while(true): 
....................                ----------------------------------------------
....................                     if(dcmotor_read_speed()==OK)
....................                      {
....................                            hien thi bien "dcmotor.speed"
....................                      }  
....................                ---------------------------------------------- 
....................               
.................... *********************************** Chuong trinh *************************************************************/
.................... #define   BOARD     D501 
.................... #include<tv_boards.c> 
.................... #ifndef    __TV_BOARDS_C__
.................... #define    __TV_BOARDS_C__
.................... #define    D401          1
.................... #define    D501          2
.................... #define    D503          3
.................... #define    MOPHONG       4
.................... #ifndef    BOARD
.................... #define    BOARD         MOPHONG
.................... #endif
.................... #if  BOARD ==  D401
.................... #include <TV_D401_TH.C>
.................... 
.................... #elif  BOARD ==  D501
.................... #include <TV_D501_TH.C>
.................... #ifndef    __TV_D501_TH_C__
.................... #define    __TV_D501_TH_C__
.................... #include<TV_D501_TH.h>
.................... #ifndef    __TV_D501_TH_H__
.................... #define    __TV_D501_TH_H__
.................... #include     <18f4550.h>
.................... //////////// Standard Header file for the PIC18F4550 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F4550
0004:  CLRF   FF7
0006:  ADDLW  14
0008:  MOVWF  FF6
000A:  MOVLW  00
000C:  ADDWFC FF7,F
000E:  TBLRD*+
0010:  MOVF   FF5,W
0012:  RETURN 0
0014:  DATA 00,00
0016:  DATA 00,00
0018:  DATA 00,00
001A:  DATA 00,5F
001C:  DATA 00,00
001E:  DATA 00,03
0020:  DATA 00,03
0022:  DATA 00,14
0024:  DATA 3E,14
0026:  DATA 3E,14
0028:  DATA 24,2A
002A:  DATA 7F,2A
002C:  DATA 12,43
002E:  DATA 33,08
0030:  DATA 66,61
0032:  DATA 36,49
0034:  DATA 55,22
0036:  DATA 50,00
0038:  DATA 05,03
003A:  DATA 00,00
003C:  DATA 00,1C
003E:  DATA 22,41
0040:  DATA 00,00
0042:  DATA 41,22
0044:  DATA 1C,00
0046:  DATA 14,08
0048:  DATA 3E,08
004A:  DATA 14,08
004C:  DATA 08,3E
004E:  DATA 08,08
0050:  DATA 00,50
0052:  DATA 30,00
0054:  DATA 00,08
0056:  DATA 08,08
0058:  DATA 08,08
005A:  DATA 00,60
005C:  DATA 60,00
005E:  DATA 00,20
0060:  DATA 10,08
0062:  DATA 04,02
0064:  DATA 3E,51
0066:  DATA 49,45
0068:  DATA 3E,00
006A:  DATA 04,02
006C:  DATA 7F,00
006E:  DATA 42,61
0070:  DATA 51,49
0072:  DATA 46,22
0074:  DATA 41,49
0076:  DATA 49,36
0078:  DATA 18,14
007A:  DATA 12,7F
007C:  DATA 10,27
007E:  DATA 45,45
0080:  DATA 45,39
0082:  DATA 3E,49
0084:  DATA 49,49
0086:  DATA 32,01
0088:  DATA 01,71
008A:  DATA 09,07
008C:  DATA 36,49
008E:  DATA 49,49
0090:  DATA 36,26
0092:  DATA 49,49
0094:  DATA 49,3E
0096:  DATA 00,36
0098:  DATA 36,00
009A:  DATA 00,00
009C:  DATA 56,36
009E:  DATA 00,00
00A0:  DATA 08,14
00A2:  DATA 22,41
00A4:  DATA 00,14
00A6:  DATA 14,14
00A8:  DATA 14,14
00AA:  DATA 00,41
00AC:  DATA 22,14
00AE:  DATA 08,02
00B0:  DATA 01,51
00B2:  DATA 09,06
00B4:  DATA 3E,41
00B6:  DATA 59,55
00B8:  DATA 5E,7E
00BA:  DATA 09,09
00BC:  DATA 09,7E
00BE:  DATA 7F,49
00C0:  DATA 49,49
00C2:  DATA 36,3E
00C4:  DATA 41,41
00C6:  DATA 41,22
00C8:  DATA 7F,41
00CA:  DATA 41,41
00CC:  DATA 3E,7F
00CE:  DATA 49,49
00D0:  DATA 49,41
00D2:  DATA 7F,09
00D4:  DATA 09,09
00D6:  DATA 01,3E
00D8:  DATA 41,41
00DA:  DATA 49,3A
00DC:  DATA 7F,08
00DE:  DATA 08,08
00E0:  DATA 7F,00
00E2:  DATA 41,7F
00E4:  DATA 41,00
00E6:  DATA 30,40
00E8:  DATA 40,40
00EA:  DATA 3F,7F
00EC:  DATA 08,14
00EE:  DATA 22,41
00F0:  DATA 7F,40
00F2:  DATA 40,40
00F4:  DATA 40,7F
00F6:  DATA 02,0C
00F8:  DATA 02,7F
00FA:  DATA 7F,02
00FC:  DATA 04,08
00FE:  DATA 7F,3E
0100:  DATA 41,41
0102:  DATA 41,3E
0104:  DATA 7F,09
0106:  DATA 09,09
0108:  DATA 06,1E
010A:  DATA 21,21
010C:  DATA 21,5E
010E:  DATA 7F,09
0110:  DATA 09,09
0112:  DATA 76,00
0114:  CLRF   FF7
0116:  ADDLW  24
0118:  MOVWF  FF6
011A:  MOVLW  01
011C:  ADDWFC FF7,F
011E:  TBLRD*+
0120:  MOVF   FF5,W
0122:  RETURN 0
0124:  DATA 26,49
0126:  DATA 49,49
0128:  DATA 32,01
012A:  DATA 01,7F
012C:  DATA 01,01
012E:  DATA 3F,40
0130:  DATA 40,40
0132:  DATA 3F,1F
0134:  DATA 20,40
0136:  DATA 20,1F
0138:  DATA 7F,20
013A:  DATA 10,20
013C:  DATA 7F,41
013E:  DATA 22,1C
0140:  DATA 22,41
0142:  DATA 07,08
0144:  DATA 70,08
0146:  DATA 07,61
0148:  DATA 51,49
014A:  DATA 45,43
014C:  DATA 00,7F
014E:  DATA 41,00
0150:  DATA 00,02
0152:  DATA 04,08
0154:  DATA 10,20
0156:  DATA 00,00
0158:  DATA 41,7F
015A:  DATA 00,04
015C:  DATA 02,01
015E:  DATA 02,04
0160:  DATA 40,40
0162:  DATA 40,40
0164:  DATA 40,00
0166:  DATA 01,02
0168:  DATA 04,00
016A:  DATA 20,54
016C:  DATA 54,54
016E:  DATA 78,7F
0170:  DATA 44,44
0172:  DATA 44,38
0174:  DATA 38,44
0176:  DATA 44,44
0178:  DATA 44,38
017A:  DATA 44,44
017C:  DATA 44,7F
017E:  DATA 38,54
0180:  DATA 54,54
0182:  DATA 18,04
0184:  DATA 04,7E
0186:  DATA 05,05
0188:  DATA 08,54
018A:  DATA 54,54
018C:  DATA 3C,7F
018E:  DATA 08,04
0190:  DATA 04,78
0192:  DATA 00,44
0194:  DATA 7D,40
0196:  DATA 00,20
0198:  DATA 40,44
019A:  DATA 3D,00
019C:  DATA 7F,10
019E:  DATA 28,44
01A0:  DATA 00,00
01A2:  DATA 41,7F
01A4:  DATA 40,00
01A6:  DATA 7C,04
01A8:  DATA 78,04
01AA:  DATA 78,7C
01AC:  DATA 08,04
01AE:  DATA 04,78
01B0:  DATA 38,44
01B2:  DATA 44,44
01B4:  DATA 38,7C
01B6:  DATA 14,14
01B8:  DATA 14,08
01BA:  DATA 08,14
01BC:  DATA 14,14
01BE:  DATA 7C,00
01C0:  DATA 7C,08
01C2:  DATA 04,04
01C4:  DATA 48,54
01C6:  DATA 54,54
01C8:  DATA 20,04
01CA:  DATA 04,3F
01CC:  DATA 44,44
01CE:  DATA 3C,40
01D0:  DATA 40,20
01D2:  DATA 7C,1C
01D4:  DATA 20,40
01D6:  DATA 20,1C
01D8:  DATA 3C,40
01DA:  DATA 30,40
01DC:  DATA 3C,44
01DE:  DATA 28,10
01E0:  DATA 28,44
01E2:  DATA 0C,50
01E4:  DATA 50,50
01E6:  DATA 3C,44
01E8:  DATA 64,54
01EA:  DATA 4C,44
01EC:  DATA 00,08
01EE:  DATA 36,41
01F0:  DATA 41,00
01F2:  DATA 00,7F
01F4:  DATA 00,00
01F6:  DATA 41,41
01F8:  DATA 36,08
01FA:  DATA 00,02
01FC:  DATA 01,02
01FE:  DATA 04,02
0200:  DATA 20,20
0202:  DATA 53,54
0204:  DATA 4F,50
0206:  DATA 20,00
0208:  DATA 46,4F
020A:  DATA 52,57
020C:  DATA 41,52
020E:  DATA 44,00
0210:  DATA 52,45
0212:  DATA 56,45
0214:  DATA 52,53
0216:  DATA 45,00
0218:  DATA 20,4C
021A:  DATA 45,56
021C:  DATA 45,4C
021E:  DATA 00,00
0220:  DATA 20,53
0222:  DATA 50,45
0224:  DATA 45,44
0226:  DATA 00,00
*
0592:  MOVLB  4
0594:  MOVF   x75,W
0596:  MULWF  x77
0598:  MOVFF  FF3,01
059C:  MOVFF  FF4,00
05A0:  MULWF  x78
05A2:  MOVF   FF3,W
05A4:  ADDWF  00,F
05A6:  MOVF   x76,W
05A8:  MULWF  x77
05AA:  MOVF   FF3,W
05AC:  ADDWFC 00,W
05AE:  MOVWF  02
05B0:  MOVLB  0
05B2:  RETURN 0
*
1146:  TBLRD*+
1148:  MOVF   FF5,F
114A:  BZ    1164
114C:  MOVFF  FF6,446
1150:  MOVFF  FF7,447
1154:  MOVFF  FF5,451
1158:  RCALL  0FAC
115A:  MOVFF  446,FF6
115E:  MOVFF  447,FF7
1162:  BRA    1146
1164:  RETURN 0
1166:  MOVLB  4
1168:  MOVF   x47,W
116A:  XORWF  x49,W
116C:  ANDLW  80
116E:  MOVWF  x4B
1170:  BTFSS  x47.7
1172:  BRA    117E
1174:  COMF   x46,F
1176:  COMF   x47,F
1178:  INCF   x46,F
117A:  BTFSC  FD8.2
117C:  INCF   x47,F
117E:  BTFSS  x49.7
1180:  BRA    118C
1182:  COMF   x48,F
1184:  COMF   x49,F
1186:  INCF   x48,F
1188:  BTFSC  FD8.2
118A:  INCF   x49,F
118C:  CLRF   01
118E:  CLRF   02
1190:  CLRF   00
1192:  CLRF   03
1194:  MOVF   x49,W
1196:  BNZ   119C
1198:  MOVF   x48,W
119A:  BZ    11CC
119C:  MOVLW  10
119E:  MOVWF  x4A
11A0:  BCF    FD8.0
11A2:  RLCF   x46,F
11A4:  RLCF   x47,F
11A6:  RLCF   00,F
11A8:  RLCF   03,F
11AA:  MOVF   x49,W
11AC:  SUBWF  03,W
11AE:  BNZ   11B4
11B0:  MOVF   x48,W
11B2:  SUBWF  00,W
11B4:  BNC   11C4
11B6:  MOVF   x48,W
11B8:  SUBWF  00,F
11BA:  BTFSS  FD8.0
11BC:  DECF   03,F
11BE:  MOVF   x49,W
11C0:  SUBWF  03,F
11C2:  BSF    FD8.0
11C4:  RLCF   01,F
11C6:  RLCF   02,F
11C8:  DECFSZ x4A,F
11CA:  BRA    11A0
11CC:  BTFSS  x4B.7
11CE:  BRA    11DA
11D0:  COMF   01,F
11D2:  COMF   02,F
11D4:  INCF   01,F
11D6:  BTFSC  FD8.2
11D8:  INCF   02,F
11DA:  MOVLB  0
11DC:  GOTO   12D6 (RETURN)
11E0:  MOVFF  FEA,450
11E4:  MOVFF  FE9,44F
11E8:  MOVLB  4
11EA:  SWAPF  x49,W
11EC:  IORLW  F0
11EE:  MOVWF  x4B
11F0:  ADDWF  x4B,F
11F2:  ADDLW  E2
11F4:  MOVWF  x4C
11F6:  ADDLW  32
11F8:  MOVWF  x4E
11FA:  MOVF   x49,W
11FC:  ANDLW  0F
11FE:  ADDWF  x4C,F
1200:  ADDWF  x4C,F
1202:  ADDWF  x4E,F
1204:  ADDLW  E9
1206:  MOVWF  x4D
1208:  ADDWF  x4D,F
120A:  ADDWF  x4D,F
120C:  SWAPF  x48,W
120E:  ANDLW  0F
1210:  ADDWF  x4D,F
1212:  ADDWF  x4E,F
1214:  RLCF   x4D,F
1216:  RLCF   x4E,F
1218:  COMF   x4E,F
121A:  RLCF   x4E,F
121C:  MOVF   x48,W
121E:  ANDLW  0F
1220:  ADDWF  x4E,F
1222:  RLCF   x4B,F
1224:  MOVLW  07
1226:  MOVWF  x4A
1228:  MOVLW  0A
122A:  DECF   x4D,F
122C:  ADDWF  x4E,F
122E:  BNC   122A
1230:  DECF   x4C,F
1232:  ADDWF  x4D,F
1234:  BNC   1230
1236:  DECF   x4B,F
1238:  ADDWF  x4C,F
123A:  BNC   1236
123C:  DECF   x4A,F
123E:  ADDWF  x4B,F
1240:  BNC   123C
1242:  MOVLW  04
1244:  MOVWF  FEA
1246:  MOVLW  4A
1248:  MOVWF  FE9
124A:  MOVLW  07
124C:  ANDWF  x4F,W
124E:  BCF    x4F.6
1250:  ADDWF  FE9,F
1252:  MOVLW  00
1254:  ADDWFC FEA,F
1256:  MOVF   FE9,W
1258:  SUBLW  4E
125A:  BNZ   1264
125C:  MOVF   FEA,W
125E:  SUBLW  04
1260:  BNZ   1264
1262:  BSF    x4F.6
1264:  MOVF   FEF,W
1266:  MOVWF  00
1268:  BNZ   127A
126A:  BTFSC  x4F.6
126C:  BRA    127A
126E:  BTFSC  x4F.4
1270:  BRA    129C
1272:  BTFSC  x4F.3
1274:  BRA    127A
1276:  MOVLW  20
1278:  BRA    1280
127A:  BSF    x4F.3
127C:  BCF    x4F.4
127E:  MOVLW  30
1280:  ADDWF  00,F
1282:  MOVFF  FEA,449
1286:  MOVFF  FE9,448
128A:  MOVFF  00,451
128E:  MOVLB  0
1290:  RCALL  0FAC
1292:  MOVFF  449,FEA
1296:  MOVFF  448,FE9
129A:  MOVLB  4
129C:  MOVF   FEE,W
129E:  BTFSS  x4F.6
12A0:  BRA    1256
12A2:  MOVLB  0
12A4:  RETURN 0
*
12F2:  MOVLB  4
12F4:  MOVF   x48,W
12F6:  ANDLW  07
12F8:  MOVWF  00
12FA:  RRCF   x48,W
12FC:  MOVWF  01
12FE:  RRCF   01,F
1300:  RRCF   01,F
1302:  MOVLW  1F
1304:  ANDWF  01,F
1306:  MOVF   01,W
1308:  ADDWF  x4A,W
130A:  MOVWF  FE9
130C:  MOVLW  00
130E:  ADDWFC x4B,W
1310:  MOVWF  FEA
1312:  CLRF   01
1314:  INCF   01,F
1316:  INCF   00,F
1318:  BRA    131C
131A:  RLCF   01,F
131C:  DECFSZ 00,F
131E:  BRA    131A
1320:  MOVF   x49,F
1322:  BZ    132A
1324:  MOVF   01,W
1326:  IORWF  FEF,F
1328:  BRA    1330
132A:  COMF   01,F
132C:  MOVF   01,W
132E:  ANDWF  FEF,F
1330:  MOVLB  0
1332:  RETURN 0
1334:  MOVLB  4
1336:  MOVF   x48,W
1338:  ANDLW  07
133A:  MOVWF  00
133C:  RRCF   x48,W
133E:  MOVWF  01
1340:  RRCF   01,F
1342:  RRCF   01,F
1344:  MOVLW  1F
1346:  ANDWF  01,F
1348:  MOVF   01,W
134A:  ADDWF  x49,W
134C:  MOVWF  FE9
134E:  MOVLW  00
1350:  ADDWFC x4A,W
1352:  MOVWF  FEA
1354:  MOVFF  FEF,01
1358:  INCF   00,F
135A:  BRA    135E
135C:  RRCF   01,F
135E:  DECFSZ 00,F
1360:  BRA    135C
1362:  MOVLW  01
1364:  ANDWF  01,F
1366:  MOVLB  0
1368:  RETURN 0
136A:  BTFSC  FD8.1
136C:  BRA    1376
136E:  MOVLW  04
1370:  MOVWF  FEA
1372:  MOVLW  59
1374:  MOVWF  FE9
1376:  CLRF   00
1378:  CLRF   01
137A:  CLRF   02
137C:  CLRF   03
137E:  MOVLB  4
1380:  CLRF   x59
1382:  CLRF   x5A
1384:  CLRF   x5B
1386:  CLRF   x5C
1388:  MOVF   x58,W
138A:  IORWF  x57,W
138C:  IORWF  x56,W
138E:  IORWF  x55,W
1390:  BZ    13EA
1392:  MOVLW  20
1394:  MOVWF  x5D
1396:  BCF    FD8.0
1398:  RLCF   x51,F
139A:  RLCF   x52,F
139C:  RLCF   x53,F
139E:  RLCF   x54,F
13A0:  RLCF   x59,F
13A2:  RLCF   x5A,F
13A4:  RLCF   x5B,F
13A6:  RLCF   x5C,F
13A8:  MOVF   x58,W
13AA:  SUBWF  x5C,W
13AC:  BNZ   13BE
13AE:  MOVF   x57,W
13B0:  SUBWF  x5B,W
13B2:  BNZ   13BE
13B4:  MOVF   x56,W
13B6:  SUBWF  x5A,W
13B8:  BNZ   13BE
13BA:  MOVF   x55,W
13BC:  SUBWF  x59,W
13BE:  BNC   13DE
13C0:  MOVF   x55,W
13C2:  SUBWF  x59,F
13C4:  MOVF   x56,W
13C6:  BTFSS  FD8.0
13C8:  INCFSZ x56,W
13CA:  SUBWF  x5A,F
13CC:  MOVF   x57,W
13CE:  BTFSS  FD8.0
13D0:  INCFSZ x57,W
13D2:  SUBWF  x5B,F
13D4:  MOVF   x58,W
13D6:  BTFSS  FD8.0
13D8:  INCFSZ x58,W
13DA:  SUBWF  x5C,F
13DC:  BSF    FD8.0
13DE:  RLCF   00,F
13E0:  RLCF   01,F
13E2:  RLCF   02,F
13E4:  RLCF   03,F
13E6:  DECFSZ x5D,F
13E8:  BRA    1396
13EA:  MOVFF  459,FEF
13EE:  MOVFF  45A,FEC
13F2:  MOVFF  45B,FEC
13F6:  MOVFF  45C,FEC
13FA:  MOVLB  0
13FC:  RETURN 0
*
16C4:  ADDWF  FE8,W
16C6:  CLRF   FF7
16C8:  RLCF   FF7,F
16CA:  ADDLW  DF
16CC:  MOVWF  FF6
16CE:  MOVLW  16
16D0:  ADDWFC FF7,F
16D2:  TBLRD*-
16D4:  MOVF   FF5,W
16D6:  MOVWF  FFA
16D8:  TBLRD*
16DA:  MOVF   FF5,W
16DC:  MOVWF  FF9
16DE:  DATA 12,15
16E0:  DATA 56,15
16E2:  DATA D0,15
16E4:  DATA 4A,16
*
1944:  ADDWF  FE8,W
1946:  CLRF   FF7
1948:  RLCF   FF7,F
194A:  ADDLW  5F
194C:  MOVWF  FF6
194E:  MOVLW  19
1950:  ADDWFC FF7,F
1952:  TBLRD*-
1954:  MOVF   FF5,W
1956:  MOVWF  FFA
1958:  TBLRD*
195A:  MOVF   FF5,W
195C:  MOVWF  FF9
195E:  DATA A8,18
1960:  DATA C8,18
1962:  DATA FC,18
1964:  DATA 1A,19
1966:  MOVLB  4
1968:  CLRF   x50
196A:  CLRF   x51
196C:  MOVLW  01
196E:  MOVWF  x52
1970:  CLRF   FDA
1972:  CLRF   FD9
1974:  MOVLW  04
1976:  MOVWF  x55
1978:  MOVLW  48
197A:  MOVWF  x54
197C:  MOVLW  04
197E:  MOVWF  FEA
1980:  MOVLW  4C
1982:  MOVWF  FE9
1984:  MOVFF  455,FE2
1988:  MOVFF  454,FE1
198C:  MOVFF  452,453
1990:  BCF    FD8.0
1992:  MOVF   FE5,W
1994:  MULWF  FEE
1996:  MOVF   FF3,W
1998:  ADDWFC x50,F
199A:  MOVF   FF4,W
199C:  ADDWFC x51,F
199E:  DECFSZ x53,F
19A0:  BRA    1990
19A2:  MOVFF  450,FDE
19A6:  MOVFF  451,450
19AA:  CLRF   x51
19AC:  BTFSC  FD8.0
19AE:  INCF   x51,F
19B0:  INCF   x54,F
19B2:  BTFSC  FD8.2
19B4:  INCF   x55,F
19B6:  INCF   x52,F
19B8:  MOVF   x52,W
19BA:  SUBLW  05
19BC:  BNZ   197C
19BE:  MOVLB  0
19C0:  GOTO   1A38 (RETURN)
.................... 
.................... #list
.................... 
.................... #device      adc=10
.................... #fuses       nowdt,put,hs,noprotect,nolvp,cpudiv1
.................... #use         delay(clock=20000000)
*
0308:  MOVLW  04
030A:  MOVWF  FEA
030C:  MOVLW  48
030E:  MOVWF  FE9
0310:  MOVF   FEF,W
0312:  BZ    032E
0314:  MOVLW  06
0316:  MOVWF  01
0318:  CLRF   00
031A:  DECFSZ 00,F
031C:  BRA    031A
031E:  DECFSZ 01,F
0320:  BRA    0318
0322:  MOVLW  7B
0324:  MOVWF  00
0326:  DECFSZ 00,F
0328:  BRA    0326
032A:  DECFSZ FEF,F
032C:  BRA    0314
032E:  RETURN 0
.................... #use         rs232(baud=9600, xmit=pin_c6,rcv=pin_c7)
.................... #include     <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float32)(unsigned int16)y;
.................... 
....................  else if (y < 10000000.0)
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
....................       res = 32768.0*(float32)l;
....................       res += (float32)(unsigned int16)y;
....................    }
.................... 
....................  else
....................   res = y;
.................... 
....................  y = y - (float32)(unsigned int16)y;
.................... 
....................  if (s)
....................   res = -res;
.................... 
....................  if (y != 0)
....................  {
....................   if (s == 1 && n == 0)
....................    res -= 1.0;
.................... 
....................   if (s == 0 && n == 1)
....................    res += 1.0;
....................  }
....................  if (x == 0)
....................     res = 0;
.................... 
....................  return (res);
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl[0]*y2 + pl[1];
.................... 
....................       r = ql[0]*y2 + ql[1];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
....................          r = -(float32)-n;
....................       else
....................          r = (float32)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... #bit         TIM3IF                 = 0xFA1.1
.................... #bit         SSDO                   = 0xF84.2
.................... #bit         SSCK                   = 0xF84.0
.................... #define      analog_pins            an0_to_an2
.................... #define      lm35a_channel          0
.................... #define      lm35b_channel          1
.................... #define      gp2d12_channel         2
.................... #define      photoresis_channel     3
.................... #define      DCMOTOR_IN1            PIN_c1
.................... #define      TOUCH_PIN              pin_a5
.................... #define      DHT11_PIN              pin_d1
.................... #define      HX711_DO               0       // khong co module nay , khai bao cho khoi bao loi
.................... #define      HX711_CLK              0       // khong co module nay , khai bao cho khoi bao loi
.................... #define      SRF04_TRIGER           PIN_E2
.................... #define      soft_i2c_sda           pin_b0
.................... #define      soft_i2c_scl           pin_b1
.................... #define      bt0                    pin_b5
.................... #define      bt1                    pin_b4
.................... #define      bt2                    pin_b3
.................... #define      bt3                    pin_b2
.................... #define      on                     bt0      
.................... #define      off                    bt1
.................... #define      inv                    bt2
.................... #define      up                     bt0    
.................... #define      dw                     bt1
.................... #define      clr                    bt2
.................... #define      mod                    bt3
.................... #define      stop                   bt3
.................... #define      on1                    bt0     
.................... #define      off1                   bt1
.................... #define      on2                    bt2       
.................... #define      off2                   bt3
.................... #define      S7SEG_RCK              pin_d5
.................... #define      LED32_RCK              pin_d4
.................... #define      D7SEG_RCK              pin_d6
.................... #define      ALLMODULE_G            pin_d0         //a - 4 byte
.................... #define      LCD_RCK                pin_d2         //a - 2 byte dao
.................... #define      RBDC_RCK               pin_d3         //b - 1 byte 
.................... #define      MATRIX_RCK             pin_d7         //b - 3 byte dao
.................... typedef enum 
.................... {
....................       OK    = 0,
....................       ERROR = 1,
....................       BUSY  = 2
.................... }result;
.................... typedef struct 
.................... {
....................       int1      STEP_MOTOR_ENABLE;
....................       int1      STEP_MOTOR_IN1;
....................       int1      STEP_MOTOR_IN2;
....................       int1      STEP_MOTOR_IN3;
....................       int1      STEP_MOTOR_IN4;
....................       int1      DC_MOTOR_ENABLE;
....................       int1      PWRKEY;
....................       int1      NC_PIN1;          
....................       int1      BUZZER;
....................       int1      TRIAC_1;
....................       int1      TRIAC_2;
....................       int1      RELAY_1;
....................       int1      RELAY_2 ;
....................       int1      NC_PIN2 ;  
....................       int1      NC_PIN3;   
....................       int1      NC_PIN4;  
.................... }RBDC_STRUCT;
.................... typedef union
.................... {
....................       RBDC_STRUCT         bit;
....................       unsigned int8       xbyte[2];
.................... }RBDC_UNION;
.................... 
.................... typedef struct 
.................... {
....................     RBDC_UNION           rbdc;
....................     unsigned int8        lcddata; 
....................     unsigned int8        lcdcontrol;
....................     unsigned int8        glcddata;
....................     unsigned int8        glcdcontrol;    
.................... }SYSTEM_VAR_STRUCT;
.................... SYSTEM_VAR_STRUCT system_var={0,0,0,0,0};
.................... typedef struct
.................... {
....................       unsigned int32 timeline;
.................... }DELAY_STRUCT;
.................... DELAY_STRUCT  delay=0;
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxx Module 32 LED don xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... typedef union 
.................... { 
....................   int1           ledx1[32];
....................   unsigned int8  ledx8[4];
....................   unsigned int16 ledx16[2];
....................   unsigned int32 ledx32; 
.................... } LED32_UNION;
.................... LED32_UNION led32;
.................... result led32_display(void);
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxx Module 7 DOAN TT xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... const unsigned int8 m7d[16]= {0XC0,0XF9,0xA4,0XB0,0X99,0X92,0X82,0XF8,0X80,0X90,0x88, 0x83, 0xC6, 0xA1, 0x86, 0x7f};
.................... typedef struct 
.................... { 
....................   unsigned int8   led[4];  
.................... } D7SEG_STRUCT; 
.................... D7SEG_STRUCT    d7seg ={0xff,0xff,0xff,0xff}; 
.................... result d7seg_display();
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxx Module 7 DOAN QUET xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... typedef struct 
.................... { 
....................   unsigned int8   led[8];  
.................... } S7SEG_STRUCT;
.................... S7SEG_STRUCT s7seg={0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff};
.................... result s7seg_display();
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxx TRIAC-BUZZER xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... result buzzer_on();
.................... result buzzer_off();
.................... result relay_1_on();
.................... result relay_1_off();
.................... result relay_2_on();
.................... result relay_2_off();
.................... result triac_1_on();
.................... result triac_1_off();
.................... result triac_2_on();
.................... result triac_2_off();
.................... result DCMOTOR_ENABLE();
.................... result STEPMOTOR_ENABLE();
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxx BASE FUNCTIONS xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... result system_init(void);
.................... void SSPI_WRITE(unsigned int8 x);
.................... #endif
.................... 
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxx Module 32 LED don xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... result led32_display()
.................... {
....................      SSPI_WRITE(led32.ledx8[3]);SSPI_WRITE(led32.ledx8[2]);
*
02B8:  MOVFF  11,451
02BC:  RCALL  0228
02BE:  MOVFF  10,451
02C2:  RCALL  0228
....................      SSPI_WRITE(led32.ledx8[1]);SSPI_WRITE(led32.ledx8[0]);
02C4:  MOVFF  0F,451
02C8:  RCALL  0228
02CA:  MOVFF  0E,451
02CE:  RCALL  0228
....................      output_high(LED32_RCK); output_low(LED32_RCK);
02D0:  BCF    F95.4
02D2:  BSF    F8C.4
02D4:  BCF    F95.4
02D6:  BCF    F8C.4
....................      return OK; 
02D8:  MOVLW  00
02DA:  MOVWF  01
02DC:  GOTO   0472 (RETURN)
.................... }
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxx Module 7 DOAN TT xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... result d7seg_display()
.................... {
....................       SSPI_WRITE(d7seg.led[0]);SSPI_WRITE(d7seg.led[1]);
02E0:  MOVFF  12,451
02E4:  RCALL  0228
02E6:  MOVFF  13,451
02EA:  RCALL  0228
....................       SSPI_WRITE(d7seg.led[2]);SSPI_WRITE(d7seg.led[3]);
02EC:  MOVFF  14,451
02F0:  RCALL  0228
02F2:  MOVFF  15,451
02F6:  RCALL  0228
....................       output_high(D7SEG_RCK); output_low(D7SEG_RCK);
02F8:  BCF    F95.6
02FA:  BSF    F8C.6
02FC:  BCF    F95.6
02FE:  BCF    F8C.6
....................       return OK;
0300:  MOVLW  00
0302:  MOVWF  01
0304:  GOTO   0474 (RETURN)
.................... }
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxx Module 7 DOAN QUET xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... result s7seg_display()
.................... {
....................       for(int8 i=0x80,n=0;n<8;n++,i>>=1)
*
0330:  MOVLW  80
0332:  MOVLB  4
0334:  MOVWF  x46
0336:  CLRF   x47
0338:  MOVF   x47,W
033A:  SUBLW  07
033C:  BNC   0390
....................       {
....................             SSPI_WRITE(i);
033E:  MOVFF  446,451
0342:  MOVLB  0
0344:  RCALL  0228
....................             SSPI_WRITE(~s7seg.led[n]);     
0346:  CLRF   03
0348:  MOVLB  4
034A:  MOVF   x47,W
034C:  ADDLW  16
034E:  MOVWF  FE9
0350:  MOVLW  00
0352:  ADDWFC 03,W
0354:  MOVWF  FEA
0356:  MOVF   FEF,W
0358:  XORLW  FF
035A:  MOVWF  x48
035C:  MOVWF  x51
035E:  MOVLB  0
0360:  RCALL  0228
....................             output_high(S7SEG_RCK); output_low(S7SEG_RCK); 
0362:  BCF    F95.5
0364:  BSF    F8C.5
0366:  BCF    F95.5
0368:  BCF    F8C.5
....................             delay_ms(1);
036A:  MOVLW  01
036C:  MOVLB  4
036E:  MOVWF  x48
0370:  MOVLB  0
0372:  RCALL  0308
....................             SSPI_WRITE(~0xff);
0374:  MOVLB  4
0376:  CLRF   x51
0378:  MOVLB  0
037A:  RCALL  0228
....................             output_high(S7SEG_RCK); output_low(S7SEG_RCK);
037C:  BCF    F95.5
037E:  BSF    F8C.5
0380:  BCF    F95.5
0382:  BCF    F8C.5
0384:  MOVLB  4
0386:  MOVF   x47,W
0388:  INCF   x47,F
038A:  BCF    FD8.0
038C:  RRCF   x46,F
038E:  BRA    0338
....................       }
....................       return OK;
0390:  MOVLW  00
0392:  MOVWF  01
0394:  MOVLB  0
0396:  GOTO   0476 (RETURN)
.................... }
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxx Module KEY4x4 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... unsigned int8 KEYREAD()
.................... {
....................      unsigned int8 cot;
....................      for(cot=0;cot<4;cot++)
....................      {
....................         output_bit(pin_b7,cot&0x02);
....................         output_bit(pin_b6,cot&0x01);
....................         IF          (!INPUT(PIN_B2))    return (3 + cot*4);             
....................         ELSE    IF  (!INPUT(PIN_B3))    return (2 + cot*4);               
....................         ELSE    IF  (!INPUT(PIN_B4))    return (1 + cot*4);            
....................         ELSE    IF  (!INPUT(PIN_B5))    return (0 + cot*4);
....................      }
....................      return 0xff;
.................... }
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxx LCD 20x4 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... result private_write_glcd_lcd()
.................... {      
....................     SSPI_WRITE(system_var.glcdcontrol);             
039A:  MOVFF  09,451
039E:  RCALL  0228
....................     SSPI_WRITE(system_var.glcddata);
03A0:  MOVFF  08,451
03A4:  RCALL  0228
....................     SSPI_WRITE(system_var.lcdcontrol);       
03A6:  MOVFF  07,451
03AA:  RCALL  0228
....................     SSPI_WRITE(system_var.lcddata);           
03AC:  MOVFF  06,451
03B0:  RCALL  0228
....................     output_high(LCD_RCK);     
03B2:  BCF    F95.2
03B4:  BSF    F8C.2
....................     output_low(LCD_RCK);
03B6:  BCF    F95.2
03B8:  BCF    F8C.2
....................     return OK;
03BA:  MOVLW  00
03BC:  MOVWF  01
03BE:  RETURN 0
.................... }
.................... result write_lcd20x4(unsigned int8 lcd_signal, lcd_ins_hthi)
.................... {     
....................     system_var.lcdcontrol = ~lcd_signal;
03C0:  MOVLB  4
03C2:  MOVFF  446,07
03C6:  COMF   07,F
....................     system_var.lcddata    = ~lcd_ins_hthi;      
03C8:  MOVFF  447,06
03CC:  COMF   06,F
....................     private_write_glcd_lcd();
03CE:  MOVLB  0
03D0:  RCALL  039A
....................     return OK;
03D2:  MOVLW  00
03D4:  MOVWF  01
03D6:  GOTO   0480 (RETURN)
.................... }
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxx GLCD 128x64 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... result write_glcd128x64(unsigned int8 glcd_signal,glcd_ins_hthi)
.................... {     
....................     system_var.glcdcontrol = ~glcd_signal;
03DA:  MOVLB  4
03DC:  MOVFF  44F,09
03E0:  COMF   09,F
....................     system_var.glcddata    = ~glcd_ins_hthi;     
03E2:  MOVFF  450,08
03E6:  COMF   08,F
....................     private_write_glcd_lcd();
03E8:  MOVLB  0
03EA:  RCALL  039A
....................     return OK;
03EC:  MOVLW  00
03EE:  MOVWF  01
03F0:  RETURN 0
.................... }
.................... //!//xxxxxxxxxxxxxxxxxxxxxxxxxxxxx LED Matrix xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... result write_ledmatrix(unsigned int16 mahang,unsigned int16 macot1,
.................... unsigned int16 macot2,unsigned int16 macot3)
.................... {     
....................       SSPI_WRITE(macot3>>8);SSPI_WRITE(macot3);
03F2:  MOVLB  4
03F4:  CLRF   x4F
03F6:  MOVFF  44D,451
03FA:  MOVLB  0
03FC:  RCALL  0228
03FE:  MOVFF  44C,451
0402:  RCALL  0228
....................       SSPI_WRITE(macot2>>8);SSPI_WRITE(macot2);
0404:  MOVLB  4
0406:  CLRF   x4F
0408:  MOVFF  44B,451
040C:  MOVLB  0
040E:  RCALL  0228
0410:  MOVFF  44A,451
0414:  RCALL  0228
....................       SSPI_WRITE(macot1>>8);SSPI_WRITE(macot1);
0416:  MOVLB  4
0418:  CLRF   x4F
041A:  MOVFF  449,451
041E:  MOVLB  0
0420:  RCALL  0228
0422:  MOVFF  448,451
0426:  RCALL  0228
....................       SSPI_WRITE(mahang>>8);SSPI_WRITE(mahang);
0428:  MOVLB  4
042A:  CLRF   x4F
042C:  MOVFF  447,451
0430:  MOVLB  0
0432:  RCALL  0228
0434:  MOVFF  446,451
0438:  RCALL  0228
....................       output_high(matrix_rck);
043A:  BCF    F95.7
043C:  BSF    F8C.7
....................       output_low(matrix_rck); 
043E:  BCF    F95.7
0440:  BCF    F8C.7
....................       return OK;
0442:  MOVLW  00
0444:  MOVWF  01
0446:  GOTO   04A0 (RETURN)
.................... }
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxx TRIAC-BUZZER xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... result private_write_buzzer_relay()
.................... {       
....................       SSPI_WRITE(system_var.rbdc.xbyte[1]);      
*
029E:  MOVFF  05,451
02A2:  RCALL  0228
....................       SSPI_WRITE(system_var.rbdc.xbyte[0]);
02A4:  MOVFF  04,451
02A8:  RCALL  0228
....................       output_high(rbdc_rck);
02AA:  BCF    F95.3
02AC:  BSF    F8C.3
....................       output_low(rbdc_rck); 
02AE:  BCF    F95.3
02B0:  BCF    F8C.3
....................       return OK;
02B2:  MOVLW  00
02B4:  MOVWF  01
02B6:  RETURN 0
.................... }
.................... result buzzer_on()
.................... {    
....................       system_var.rbdc.bit.buzzer=1;
....................       private_write_buzzer_relay();
....................       return OK;
.................... }
.................... result buzzer_off()
.................... {     
....................       system_var.rbdc.bit.buzzer=0;
....................       private_write_buzzer_relay();  
....................       return OK;
.................... }
.................... result relay_1_on()
.................... {    
....................       system_var.rbdc.bit.relay_1=1;
....................       private_write_buzzer_relay(); 
....................       return OK;
.................... }
.................... result relay_1_off()
.................... {    
....................       system_var.rbdc.bit.relay_1=0;
....................       private_write_buzzer_relay();  
....................       return OK;
.................... }
.................... result relay_2_on()
.................... {    
....................       system_var.rbdc.bit.relay_2=1;
....................       private_write_buzzer_relay(); 
....................       return OK;
.................... }
.................... result relay_2_off()
.................... {    
....................       system_var.rbdc.bit.relay_2=0;
....................       private_write_buzzer_relay(); 
....................       return OK;
.................... }
.................... result triac_1_on()
.................... {    
....................       system_var.rbdc.bit.triac_1=1;
....................       private_write_buzzer_relay(); 
....................       return OK;
.................... }
.................... result triac_1_off()
.................... {    
....................       system_var.rbdc.bit.triac_1=0;
....................       private_write_buzzer_relay();   
....................       return OK;
.................... }
.................... result triac_2_on()
.................... {    
....................       system_var.rbdc.bit.triac_2=1;
....................       private_write_buzzer_relay();
....................       return OK;
.................... }
.................... result triac_2_off()
.................... {    
....................       system_var.rbdc.bit.triac_2=0;
....................       private_write_buzzer_relay();   
....................       return OK;
.................... }
.................... result DCMOTOR_ENABLE()
.................... {
....................       system_var.rbdc.bit.DC_MOTOR_ENABLE=1;
*
16E6:  BSF    04.5
....................       private_write_buzzer_relay();  
16E8:  CALL   029E
....................       setup_timer_2(t2_div_by_16,249,1);  // Cau hinh xung PWM T=0.8 ms, su dung PWM1
16EC:  MOVLW  00
16EE:  IORLW  06
16F0:  MOVWF  FCA
16F2:  MOVLW  F9
16F4:  MOVWF  FCB
....................       setup_ccp1(ccp_pwm);  
16F6:  BCF    F94.2
16F8:  BCF    F8B.2
16FA:  MOVLW  0C
16FC:  MOVWF  FBD
16FE:  CLRF   FB7
1700:  CLRF   FB6
....................       setup_ccp2(ccp_pwm);  
1702:  BCF    F94.1
1704:  BCF    F8B.1
1706:  MOVWF  FBA
....................       return OK;
1708:  MOVLW  00
170A:  MOVWF  01
170C:  GOTO   18AA (RETURN)
.................... }
.................... result DCMOTOR_LOWLEVEL_CONTROL(signed int16 duty, int1 direct)
.................... {
....................      if(duty)
1710:  MOVLB  4
1712:  MOVF   x4B,W
1714:  IORWF  x4C,W
1716:  BZ    177C
....................         if(direct){ set_pwm1_duty((int16)0);  set_pwm2_duty(duty);  }
1718:  MOVF   x4D,F
171A:  BZ    174C
171C:  CLRF   FBE
171E:  MOVF   FBD,W
1720:  ANDLW  CF
1722:  MOVWF  FBD
1724:  MOVFF  44C,02
1728:  MOVFF  44B,01
172C:  RRCF   02,F
172E:  RRCF   01,F
1730:  RRCF   02,F
1732:  RRCF   01,F
1734:  RRCF   02,F
1736:  MOVFF  01,FBB
173A:  RRCF   02,F
173C:  RRCF   02,W
173E:  ANDLW  30
1740:  MOVWF  00
1742:  MOVF   FBA,W
1744:  ANDLW  CF
1746:  IORWF  00,W
1748:  MOVWF  FBA
174A:  BRA    177A
....................         else      { set_pwm2_duty((int16)0);  set_pwm1_duty(duty);  }
174C:  CLRF   FBB
174E:  MOVF   FBA,W
1750:  ANDLW  CF
1752:  MOVWF  FBA
1754:  MOVFF  44C,02
1758:  MOVFF  44B,01
175C:  RRCF   02,F
175E:  RRCF   01,F
1760:  RRCF   02,F
1762:  RRCF   01,F
1764:  RRCF   02,F
1766:  MOVFF  01,FBE
176A:  RRCF   02,F
176C:  RRCF   02,W
176E:  ANDLW  30
1770:  MOVWF  00
1772:  MOVF   FBD,W
1774:  ANDLW  CF
1776:  IORWF  00,W
1778:  MOVWF  FBD
177A:  BRA    178C
....................      else         { set_pwm1_duty((int16)0);  set_pwm2_duty((int16)0);  }
177C:  CLRF   FBE
177E:  MOVF   FBD,W
1780:  ANDLW  CF
1782:  MOVWF  FBD
1784:  CLRF   FBB
1786:  MOVF   FBA,W
1788:  ANDLW  CF
178A:  MOVWF  FBA
....................      return OK;
178C:  MOVLW  00
178E:  MOVWF  01
1790:  MOVLB  0
1792:  RETURN 0
.................... }
.................... 
.................... result STEPMOTOR_ENABLE()
.................... {
....................       system_var.rbdc.bit.step_motor_enable=1;
....................       return OK;
.................... }
.................... result STEPMOTOR_LOWLEVEL_CONTROL(int1 mode, int8 step)
.................... {                                                                      
....................       const unsigned int8 Step_data[2][8]={0x0e,0x0a,0x0b,0x08,0x01,0x05,0x04,0x06,0x0e,0x0b,0x0d,0x07,0x0e,0x0b,0x0d,0x07};
....................       system_var.rbdc.bit.step_motor_in1=bit_test(Step_data[mode][step],0);
....................       system_var.rbdc.bit.step_motor_in2=bit_test(Step_data[mode][step],1);
....................       system_var.rbdc.bit.step_motor_in3=bit_test(Step_data[mode][step],2);
....................       system_var.rbdc.bit.step_motor_in4=bit_test(Step_data[mode][step],3);
....................       private_write_buzzer_relay();
....................       return OK;
.................... }
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxx BOARD_INIT xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... result system_init()
.................... {
....................      output_high(ALLMODULE_G);  
*
044A:  BCF    F95.0
044C:  BSF    F8C.0
....................      set_tris_a(0xff);    set_tris_b(0x3c);                                                   
044E:  MOVLW  FF
0450:  MOVWF  F92
0452:  MOVLW  3C
0454:  MOVWF  F93
....................      set_tris_c(0xf1);    set_tris_e(0x00);                                               
0456:  MOVLW  F1
0458:  MOVWF  F94
045A:  MOVLW  00
045C:  MOVWF  F96
....................      set_tris_d(0x00);    output_d(0x00); 
045E:  MOVWF  F95
0460:  CLRF   F95
0462:  CLRF   F8C
....................      port_b_pullups(0xff); 
0464:  BCF    FF1.7
....................      private_write_buzzer_relay();
0466:  RCALL  029E
....................      led32.ledx32=0;
0468:  CLRF   11
046A:  CLRF   10
046C:  CLRF   0F
046E:  CLRF   0E
....................      led32_display();
0470:  BRA    02B8
....................      d7seg_display();
0472:  BRA    02E0
....................      s7seg_display();
0474:  BRA    0330
....................      write_lcd20x4(0xff,0xff);
0476:  MOVLB  4
0478:  SETF   x46
047A:  SETF   x47
047C:  MOVLB  0
047E:  BRA    03C0
....................      write_glcd128x64(0xff,0xff);
0480:  MOVLB  4
0482:  SETF   x4F
0484:  SETF   x50
0486:  MOVLB  0
0488:  RCALL  03DA
....................      write_ledmatrix(0,0,0,0); 
048A:  MOVLB  4
048C:  CLRF   x47
048E:  CLRF   x46
0490:  CLRF   x49
0492:  CLRF   x48
0494:  CLRF   x4B
0496:  CLRF   x4A
0498:  CLRF   x4D
049A:  CLRF   x4C
049C:  MOVLB  0
049E:  BRA    03F2
....................      output_low(ALLMODULE_G);  
04A0:  BCF    F95.0
04A2:  BCF    F8C.0
....................      setup_adc(adc_clock_div_32);        
04A4:  MOVF   FC0,W
04A6:  ANDLW  C0
04A8:  IORLW  02
04AA:  MOVWF  FC0
04AC:  BSF    FC0.7
04AE:  BSF    FC2.0
....................      setup_adc_ports(an0_to_an2|vss_vdd);   
04B0:  MOVF   FC1,W
04B2:  ANDLW  C0
04B4:  IORLW  0C
04B6:  MOVWF  FC1
....................      setup_timer_3(t3_internal|t3_div_by_8);
04B8:  MOVLW  B5
04BA:  MOVWF  FB1
....................      return OK;
04BC:  MOVLW  00
04BE:  MOVWF  01
04C0:  GOTO   1BCC (RETURN)
.................... }
.................... void SSPI_WRITE(unsigned int8 x)
.................... { 
....................          if(x&0x80) ssdo=1; 
*
0228:  MOVLB  4
022A:  BTFSS  x51.7
022C:  BRA    0232
022E:  BSF    F84.2
0230:  BRA    0234
....................          else       ssdo=0;
0232:  BCF    F84.2
....................          ssck=0;    ssck=1;   
0234:  BCF    F84.0
0236:  BSF    F84.0
....................          if(x&0x40) ssdo=1; 
0238:  BTFSS  x51.6
023A:  BRA    0240
023C:  BSF    F84.2
023E:  BRA    0242
....................          else       ssdo=0;
0240:  BCF    F84.2
....................          ssck=0;    ssck=1;  
0242:  BCF    F84.0
0244:  BSF    F84.0
....................          if(x&0x20) ssdo=1; 
0246:  BTFSS  x51.5
0248:  BRA    024E
024A:  BSF    F84.2
024C:  BRA    0250
....................          else       ssdo=0;
024E:  BCF    F84.2
....................          ssck=0;    ssck=1;  
0250:  BCF    F84.0
0252:  BSF    F84.0
....................          if(x&0x10) ssdo=1; 
0254:  BTFSS  x51.4
0256:  BRA    025C
0258:  BSF    F84.2
025A:  BRA    025E
....................          else       ssdo=0;
025C:  BCF    F84.2
....................          ssck=0;    ssck=1;  
025E:  BCF    F84.0
0260:  BSF    F84.0
....................          if(x&0x08) ssdo=1; 
0262:  BTFSS  x51.3
0264:  BRA    026A
0266:  BSF    F84.2
0268:  BRA    026C
....................          else       ssdo=0;
026A:  BCF    F84.2
....................          ssck=0;    ssck=1;  
026C:  BCF    F84.0
026E:  BSF    F84.0
....................          if(x&0x04) ssdo=1; 
0270:  BTFSS  x51.2
0272:  BRA    0278
0274:  BSF    F84.2
0276:  BRA    027A
....................          else       ssdo=0;
0278:  BCF    F84.2
....................          ssck=0;    ssck=1;  
027A:  BCF    F84.0
027C:  BSF    F84.0
....................          if(x&0x02) ssdo=1; 
027E:  BTFSS  x51.1
0280:  BRA    0286
0282:  BSF    F84.2
0284:  BRA    0288
....................          else       ssdo=0;
0286:  BCF    F84.2
....................          ssck=0;    ssck=1;  
0288:  BCF    F84.0
028A:  BSF    F84.0
....................          if(x&0x01) ssdo=1; 
028C:  BTFSS  x51.0
028E:  BRA    0294
0290:  BSF    F84.2
0292:  BRA    0296
....................          else       ssdo=0;
0294:  BCF    F84.2
....................          ssck=0;    ssck=1;       
0296:  BCF    F84.0
0298:  BSF    F84.0
029A:  MOVLB  0
029C:  RETURN 0
.................... }
.................... #endif
.................... 
....................  
.................... #elif  BOARD ==  D503
.................... #include <TV_D501_TH.C>
.................... 
.................... #else 
.................... #include <TV_MOPHONG.C>
.................... #warning"Day la file mo phong, SV khong duoc nap tren board that"
.................... #endif
.................... #include <TV_LOWLEVER.C>
.................... #ifndef  __TV_LOWLEVER_C__
.................... #define  __TV_LOWLEVER_C__
.................... #include <TV_LOWLEVER.H>
.................... #ifndef  __TV_LOWLEVER_H__
.................... #define  __TV_LOWLEVER_H__
.................... unsigned int16 delay_start();
.................... unsigned int16 delay_stop(unsigned int16 t);
.................... result inputcd(int16 pin);
.................... #endif
.................... 
.................... /*********************************** Soft I2C ************************************************************/
.................... #if      BOARD == MOPHONG
.................... result soft_i2c_clk()
.................... {   
....................       output_high(soft_i2c_scl);
....................       DELAY_us(1);  
....................       output_low(soft_i2c_scl);
....................       return OK;
.................... }
.................... result soft_i2c_start()
.................... {
....................       output_high(soft_i2c_sda);
....................       output_high(soft_i2c_scl);
....................       delay_us(1);
....................       output_low(soft_i2c_sda);
....................       delay_us(1);
....................       output_low(soft_i2c_scl);   
....................       return OK;
.................... }
.................... result soft_i2c_stop()
.................... {
....................       output_low(soft_i2c_sda);
....................       output_high(soft_i2c_scl);
....................       delay_us(1);
....................       output_high(soft_i2c_sda);
....................       return OK;
.................... }
.................... result soft_i2c_write(unsigned int8 b)
.................... {
....................       unsigned int8 m;
....................       int1 ack;
....................       for(m=0x80;m>0;m>>=1)
....................       {
....................             output_bit( soft_i2c_sda,b&m);
....................             soft_i2c_clk();
....................       }
....................       output_float(soft_i2c_sda);
....................       output_high(soft_i2c_scl);  
....................       delay_us(1);
....................       ack = input(soft_i2c_sda);
....................       output_low(soft_i2c_scl);  
....................       return ack;
.................... }
.................... 
.................... unsigned int8 soft_i2c_read(int1 ack)
.................... { 
....................       unsigned int8 n,nhan=0;
....................       output_float(soft_i2c_sda);
....................       for(n=0x80;n>0;n>>=1)
....................       {      
....................             output_high(soft_i2c_scl);  
....................             delay_us(1);
....................             if(input(soft_i2c_sda))nhan=nhan|n;
....................             output_low(soft_i2c_scl);   
....................       }
....................       if(ack)  output_low(soft_i2c_sda);
....................       else     output_high(soft_i2c_sda); 
....................       soft_i2c_clk();
....................       output_high(soft_i2c_sda); 
....................       return nhan;
.................... }
.................... #else 
.................... void soft_i2c_clk()
.................... {    
....................       output_high(soft_i2c_scl);
....................       output_low(soft_i2c_scl);
.................... }
.................... void soft_i2c_start()
.................... {
....................       output_high(soft_i2c_sda);
....................       output_high(soft_i2c_scl);
....................       output_low(soft_i2c_sda);
....................       output_low(soft_i2c_scl);      
.................... }
.................... void soft_i2c_stop()
.................... {
....................       output_low(soft_i2c_scl);
....................       output_low(soft_i2c_sda);
....................       output_high(soft_i2c_scl);
....................       output_high(soft_i2c_sda);
.................... }
.................... result soft_i2c_write(unsigned int8 b)
.................... {
....................       unsigned int8 m,dem=0;
....................       for(m=0x80;m>0;m>>=1)
....................       {
....................             output_bit(soft_i2c_sda,b&m);
....................             soft_i2c_clk();
....................       }
....................      output_float(soft_i2c_sda);
....................      output_high(soft_i2c_scl);
....................      while(input(soft_i2c_sda)&(dem<5)){dem++; delay_us(1);}
....................      output_low(soft_i2c_scl);
....................      if(dem==5) return ERROR;
....................      else        return OK;
.................... }
.................... 
.................... unsigned int8 soft_i2c_read(int1 ack)
.................... { 
....................       unsigned int8 n,nhan=0;
....................       output_float(soft_i2c_sda);
....................       for(n=0x80;n>0;n>>=1)
....................       {    
....................             output_high(soft_i2c_scl);  
....................             if(input(soft_i2c_sda))nhan=nhan|n; 
....................             output_low(soft_i2c_scl);  
....................       } 
....................       output_bit(soft_i2c_sda,!ack);
....................       soft_i2c_clk();
....................       return nhan;
.................... }
.................... #endif
.................... /*********************************** Delay ************************************************************/
.................... unsigned int16 delay_start()
.................... {    
....................       delay.timeline += get_timer3() ;set_timer3(2);
*
13FE:  MOVF   FB2,W
1400:  MOVFF  FB3,03
1404:  ADDWF  0A,F
1406:  MOVF   FB3,W
1408:  ADDWFC 0B,F
140A:  MOVLW  00
140C:  ADDWFC 0C,F
140E:  ADDWFC 0D,F
1410:  CLRF   FB3
1412:  MOVLW  02
1414:  MOVWF  FB2
1416:  NOP   
....................       if(TIM3IF) delay.timeline +=65536;TIM3IF=0;
1418:  BTFSS  FA1.1
141A:  BRA    1424
141C:  MOVLW  01
141E:  ADDWF  0C,F
1420:  MOVLW  00
1422:  ADDWFC 0D,F
1424:  BCF    FA1.1
....................       return delay.timeline/625;
1426:  BCF    FD8.1
1428:  MOVFF  0D,454
142C:  MOVFF  0C,453
1430:  MOVFF  0B,452
1434:  MOVFF  0A,451
1438:  MOVLB  4
143A:  CLRF   x58
143C:  CLRF   x57
143E:  MOVLW  02
1440:  MOVWF  x56
1442:  MOVLW  71
1444:  MOVWF  x55
1446:  MOVLB  0
1448:  RCALL  136A
144A:  MOVFF  01,02
144E:  MOVFF  00,01
1452:  RETURN 0
.................... }
.................... 
.................... unsigned int16 delay_stop(unsigned int16 t)
.................... {    
....................       unsigned int16 tam;
....................       delay.timeline += get_timer3() ;set_timer3(2);
1454:  MOVF   FB2,W
1456:  MOVFF  FB3,03
145A:  ADDWF  0A,F
145C:  MOVF   FB3,W
145E:  ADDWFC 0B,F
1460:  MOVLW  00
1462:  ADDWFC 0C,F
1464:  ADDWFC 0D,F
1466:  CLRF   FB3
1468:  MOVLW  02
146A:  MOVWF  FB2
146C:  NOP   
....................       if(TIM3IF) delay.timeline +=65536;TIM3IF=0;
146E:  BTFSS  FA1.1
1470:  BRA    147A
1472:  MOVLW  01
1474:  ADDWF  0C,F
1476:  MOVLW  00
1478:  ADDWFC 0D,F
147A:  BCF    FA1.1
....................       tam = delay.timeline/625;
147C:  BCF    FD8.1
147E:  MOVFF  0D,454
1482:  MOVFF  0C,453
1486:  MOVFF  0B,452
148A:  MOVFF  0A,451
148E:  MOVLB  4
1490:  CLRF   x58
1492:  CLRF   x57
1494:  MOVLW  02
1496:  MOVWF  x56
1498:  MOVLW  71
149A:  MOVWF  x55
149C:  MOVLB  0
149E:  RCALL  136A
14A0:  MOVFF  01,450
14A4:  MOVFF  00,44F
....................       if(t<=tam) return tam-t;
14A8:  MOVLB  4
14AA:  MOVF   x4E,W
14AC:  SUBWF  x50,W
14AE:  BNC   14CE
14B0:  BNZ   14B8
14B2:  MOVF   x4D,W
14B4:  SUBWF  x4F,W
14B6:  BNC   14CE
14B8:  MOVF   x4D,W
14BA:  SUBWF  x4F,W
14BC:  MOVWF  00
14BE:  MOVF   x4E,W
14C0:  SUBWFB x50,W
14C2:  MOVWF  03
14C4:  MOVFF  00,01
14C8:  MOVWF  02
14CA:  BRA    14EA
14CC:  BRA    14EA
....................       else       return 0xffff-t + tam;
14CE:  MOVLW  FF
14D0:  BSF    FD8.0
14D2:  SUBFWB x4D,W
14D4:  MOVWF  x51
14D6:  MOVLW  FF
14D8:  SUBFWB x4E,W
14DA:  MOVWF  x52
14DC:  MOVF   x4F,W
14DE:  ADDWF  x51,W
14E0:  MOVWF  01
14E2:  MOVF   x50,W
14E4:  ADDWFC x52,W
14E6:  MOVWF  03
14E8:  MOVWF  02
14EA:  MOVLB  0
14EC:  RETURN 0
.................... }
.................... /*********************************** Button ************************************************************/
.................... result inputcd(int16 pin)
.................... {
....................       static unsigned int16 oldpin=0xffff;
....................       static unsigned int16 t; 
....................       static unsigned int8 step=0;
....................       output_float(pin);
14EE:  MOVFF  446,448
14F2:  MOVLW  01
14F4:  MOVLB  4
14F6:  MOVWF  x49
14F8:  MOVLW  0F
14FA:  MOVWF  x4B
14FC:  MOVLW  92
14FE:  MOVWF  x4A
1500:  MOVLB  0
1502:  RCALL  12F2
....................       switch (step)
1504:  MOVF   22,W
1506:  ADDLW  FC
1508:  BTFSC  FD8.0
150A:  BRA    16BE
150C:  ADDLW  04
150E:  GOTO   16C4
....................       {
....................           case 0:
....................                  if(input(pin)==0)
1512:  MOVFF  446,448
1516:  MOVLW  01
1518:  MOVLB  4
151A:  MOVWF  x49
151C:  MOVLW  0F
151E:  MOVWF  x4B
1520:  MOVLW  92
1522:  MOVWF  x4A
1524:  MOVLB  0
1526:  RCALL  12F2
1528:  MOVFF  446,448
152C:  MOVLW  0F
152E:  MOVLB  4
1530:  MOVWF  x4A
1532:  MOVLW  80
1534:  MOVWF  x49
1536:  MOVLB  0
1538:  RCALL  1334
153A:  BTFSC  01.0
153C:  BRA    1554
....................                   {
....................                         oldpin   = pin;
153E:  MOVFF  447,1F
1542:  MOVFF  446,1E
....................                         t        = delay_start();
1546:  RCALL  13FE
1548:  MOVFF  02,21
154C:  MOVFF  01,20
....................                         step     = 1;
1550:  MOVLW  01
1552:  MOVWF  22
....................                   }
....................                  break;
1554:  BRA    16BE
....................            case 1:
....................                  if(input(oldpin))step = 0;
1556:  MOVFF  1E,448
155A:  MOVLW  01
155C:  MOVLB  4
155E:  MOVWF  x49
1560:  MOVLW  0F
1562:  MOVWF  x4B
1564:  MOVLW  92
1566:  MOVWF  x4A
1568:  MOVLB  0
156A:  RCALL  12F2
156C:  MOVFF  1E,448
1570:  MOVLW  0F
1572:  MOVLB  4
1574:  MOVWF  x4A
1576:  MOVLW  80
1578:  MOVWF  x49
157A:  MOVLB  0
157C:  RCALL  1334
157E:  BTFSS  01.0
1580:  BRA    1586
1582:  CLRF   22
1584:  BRA    15CA
....................                  else if((pin==oldpin)&&(delay_stop(t)>=30))
1586:  MOVF   1E,W
1588:  MOVLB  4
158A:  SUBWF  x46,W
158C:  BNZ   15CC
158E:  MOVF   1F,W
1590:  SUBWF  x47,W
1592:  BNZ   15CC
1594:  MOVFF  21,44E
1598:  MOVFF  20,44D
159C:  MOVLB  0
159E:  RCALL  1454
15A0:  MOVFF  02,449
15A4:  MOVFF  01,448
15A8:  MOVLB  4
15AA:  MOVF   x49,F
15AC:  BNZ   15B4
15AE:  MOVF   x48,W
15B0:  SUBLW  1D
15B2:  BC    15CC
....................                    {
....................                       t    = delay_start();
15B4:  MOVLB  0
15B6:  RCALL  13FE
15B8:  MOVFF  02,21
15BC:  MOVFF  01,20
....................                       step = 2;
15C0:  MOVLW  02
15C2:  MOVWF  22
....................                       return OK;
15C4:  MOVLW  00
15C6:  MOVWF  01
15C8:  BRA    16C2
15CA:  MOVLB  4
....................                    }
....................                  break;
15CC:  MOVLB  0
15CE:  BRA    16BE
....................             case 2:
....................                  if(input(oldpin))step = 0;
15D0:  MOVFF  1E,448
15D4:  MOVLW  01
15D6:  MOVLB  4
15D8:  MOVWF  x49
15DA:  MOVLW  0F
15DC:  MOVWF  x4B
15DE:  MOVLW  92
15E0:  MOVWF  x4A
15E2:  MOVLB  0
15E4:  RCALL  12F2
15E6:  MOVFF  1E,448
15EA:  MOVLW  0F
15EC:  MOVLB  4
15EE:  MOVWF  x4A
15F0:  MOVLW  80
15F2:  MOVWF  x49
15F4:  MOVLB  0
15F6:  RCALL  1334
15F8:  BTFSS  01.0
15FA:  BRA    1600
15FC:  CLRF   22
15FE:  BRA    1644
....................                  else if((pin==oldpin)&&(delay_stop(t)>=500))
1600:  MOVF   1E,W
1602:  MOVLB  4
1604:  SUBWF  x46,W
1606:  BNZ   1646
1608:  MOVF   1F,W
160A:  SUBWF  x47,W
160C:  BNZ   1646
160E:  MOVFF  21,44E
1612:  MOVFF  20,44D
1616:  MOVLB  0
1618:  RCALL  1454
161A:  MOVFF  02,449
161E:  MOVFF  01,448
1622:  MOVLB  4
1624:  MOVF   02,W
1626:  SUBLW  00
1628:  BC    1646
162A:  XORLW  FF
162C:  BNZ   1634
162E:  MOVF   x48,W
1630:  SUBLW  F3
1632:  BC    1646
....................                    {
....................                        t        = delay_start();
1634:  MOVLB  0
1636:  RCALL  13FE
1638:  MOVFF  02,21
163C:  MOVFF  01,20
....................                        step     = 3;
1640:  MOVLW  03
1642:  MOVWF  22
1644:  MOVLB  4
....................                    } 
....................                  break;
1646:  MOVLB  0
1648:  BRA    16BE
....................             case 3:
....................                    if(input(oldpin))step = 0; 
164A:  MOVFF  1E,448
164E:  MOVLW  01
1650:  MOVLB  4
1652:  MOVWF  x49
1654:  MOVLW  0F
1656:  MOVWF  x4B
1658:  MOVLW  92
165A:  MOVWF  x4A
165C:  MOVLB  0
165E:  RCALL  12F2
1660:  MOVFF  1E,448
1664:  MOVLW  0F
1666:  MOVLB  4
1668:  MOVWF  x4A
166A:  MOVLW  80
166C:  MOVWF  x49
166E:  MOVLB  0
1670:  RCALL  1334
1672:  BTFSS  01.0
1674:  BRA    167A
1676:  CLRF   22
1678:  BRA    16BA
....................                    else if((pin==oldpin)&&(delay_stop(t)>=100))
167A:  MOVF   1E,W
167C:  MOVLB  4
167E:  SUBWF  x46,W
1680:  BNZ   16BC
1682:  MOVF   1F,W
1684:  SUBWF  x47,W
1686:  BNZ   16BC
1688:  MOVFF  21,44E
168C:  MOVFF  20,44D
1690:  MOVLB  0
1692:  RCALL  1454
1694:  MOVFF  02,449
1698:  MOVFF  01,448
169C:  MOVLB  4
169E:  MOVF   x49,F
16A0:  BNZ   16A8
16A2:  MOVF   x48,W
16A4:  SUBLW  63
16A6:  BC    16BC
....................                        {
....................                           t  = delay_start();
16A8:  MOVLB  0
16AA:  RCALL  13FE
16AC:  MOVFF  02,21
16B0:  MOVFF  01,20
....................                           return OK;
16B4:  MOVLW  00
16B6:  MOVWF  01
16B8:  BRA    16C2
16BA:  MOVLB  4
....................                        }
....................                  break;
16BC:  MOVLB  0
....................       }   
....................       return BUSY; 
16BE:  MOVLW  02
16C0:  MOVWF  01
16C2:  RETURN 0
.................... }
.................... #endif
.................... 
.................... #ignore_warnings 202
.................... #endif
.................... 
.................... #include<tv_dcmotor.c>
.................... #ifndef  __TV_DCMOTOR_C__
.................... #define  __TV_DCMOTOR_C__
.................... #include <TV_DCMOTOR.h>
.................... #ifndef  __TV_DCMOTOR_H__
.................... #define  __TV_DCMOTOR_H__
.................... #define  SPEEDMUL  1333
.................... typedef enum
.................... {
....................       dcmotor_direct_forward  = 1,
....................       dcmotor_direct_reverse  = 0
.................... }DCMOTOR_DIRECT;
.................... typedef struct
.................... {
....................       signed int16             duty;
....................       DCMOTOR_DIRECT           direct;
....................       unsigned int16           speed;
.................... }
.................... DCMOTOR_STRUCT ;
.................... DCMOTOR_STRUCT dcmotor={0,1,0};
.................... DCMOTOR_STRUCT nowdcmotor={0,1,0};
.................... result dcmotor_control(void);
.................... result dcmotor_read_speed(void);
.................... #warning "Khi goi ham "dcmotor_read_speed" TIMER1 duoc cau hinh chuc nang COUTNER => Chu y cac ung dung truoc do da su dung TIMER1"
.................... #endif
.................... 
.................... result DCMOTOR_MIDDLELEVEL_CONTROL(signed int16 duty,int1 direct)
*
1794:  MOVLW  02
1796:  MOVLB  4
1798:  MOVWF  x4A
.................... {
....................      static unsigned int32 t=0;
....................      result tt=BUSY;
....................      if(nowdcmotor.duty<duty)
179A:  BTFSS  29.7
179C:  BRA    17A4
179E:  BTFSS  x48.7
17A0:  BRA    17B6
17A2:  BRA    17A8
17A4:  BTFSC  x48.7
17A6:  BRA    1826
17A8:  MOVF   29,W
17AA:  SUBWF  x48,W
17AC:  BNC   1826
17AE:  BNZ   17B6
17B0:  MOVF   x47,W
17B2:  SUBWF  28,W
17B4:  BC    1826
....................       {
....................        if(delay_stop(t)>=20)
17B6:  MOVFF  2E,44E
17BA:  MOVFF  2D,44D
17BE:  MOVLB  0
17C0:  RCALL  1454
17C2:  MOVFF  02,44C
17C6:  MOVFF  01,44B
17CA:  MOVLB  4
17CC:  MOVF   x4C,F
17CE:  BNZ   17D6
17D0:  MOVF   x4B,W
17D2:  SUBLW  13
17D4:  BC    1824
....................            {
....................                nowdcmotor.duty+=50;
17D6:  MOVLW  32
17D8:  ADDWF  28,F
17DA:  MOVLW  00
17DC:  ADDWFC 29,F
....................                if(nowdcmotor.duty>=duty) {nowdcmotor.duty=duty;tt= OK;}
17DE:  BTFSS  x48.7
17E0:  BRA    17E8
17E2:  BTFSS  29.7
17E4:  BRA    17FA
17E6:  BRA    17EC
17E8:  BTFSC  29.7
17EA:  BRA    1804
17EC:  MOVF   x48,W
17EE:  SUBWF  29,W
17F0:  BNC   1804
17F2:  BNZ   17FA
17F4:  MOVF   x47,W
17F6:  SUBWF  28,W
17F8:  BNC   1804
17FA:  MOVFF  448,29
17FE:  MOVFF  447,28
1802:  CLRF   x4A
....................                DCMOTOR_LOWLEVEL_CONTROL(nowdcmotor.duty,direct);
1804:  MOVFF  29,44C
1808:  MOVFF  28,44B
180C:  MOVFF  449,44D
1810:  MOVLB  0
1812:  RCALL  1710
....................                t = delay_start();
1814:  RCALL  13FE
1816:  CLRF   30
1818:  CLRF   2F
181A:  MOVFF  02,2E
181E:  MOVFF  01,2D
1822:  MOVLB  4
....................            }
....................       }
1824:  BRA    1894
....................      else if(delay_stop(t)>=20)
1826:  MOVFF  2E,44E
182A:  MOVFF  2D,44D
182E:  MOVLB  0
1830:  RCALL  1454
1832:  MOVFF  02,44C
1836:  MOVFF  01,44B
183A:  MOVLB  4
183C:  MOVF   x4C,F
183E:  BNZ   1846
1840:  MOVF   x4B,W
1842:  SUBLW  13
1844:  BC    1894
....................       {
....................                nowdcmotor.duty-=50;
1846:  MOVLW  32
1848:  SUBWF  28,F
184A:  MOVLW  00
184C:  SUBWFB 29,F
....................                if(nowdcmotor.duty<=duty){nowdcmotor.duty=duty;tt= OK;}
184E:  BTFSS  29.7
1850:  BRA    1858
1852:  BTFSS  x48.7
1854:  BRA    186A
1856:  BRA    185C
1858:  BTFSC  x48.7
185A:  BRA    1874
185C:  MOVF   29,W
185E:  SUBWF  x48,W
1860:  BNC   1874
1862:  BNZ   186A
1864:  MOVF   28,W
1866:  SUBWF  x47,W
1868:  BNC   1874
186A:  MOVFF  448,29
186E:  MOVFF  447,28
1872:  CLRF   x4A
....................                DCMOTOR_LOWLEVEL_CONTROL(nowdcmotor.duty,direct);
1874:  MOVFF  29,44C
1878:  MOVFF  28,44B
187C:  MOVFF  449,44D
1880:  MOVLB  0
1882:  RCALL  1710
....................                t = delay_start();
1884:  RCALL  13FE
1886:  CLRF   30
1888:  CLRF   2F
188A:  MOVFF  02,2E
188E:  MOVFF  01,2D
1892:  MOVLB  4
....................       }
....................      return tt;
1894:  MOVFF  44A,01
1898:  MOVLB  0
189A:  RETURN 0
.................... }
.................... result dcmotor_control()
.................... {
....................         static int8 step=0;
....................         switch (step)
189C:  MOVF   31,W
189E:  ADDLW  FC
18A0:  BC    193C
18A2:  ADDLW  04
18A4:  GOTO   1944
....................         {
....................               case 0:
....................                     DCMOTOR_ENABLE();
18A8:  BRA    16E6
....................                     DCMOTOR_MIDDLELEVEL_CONTROL(dcmotor.duty,dcmotor.direct) ;
18AA:  MOVLW  00
18AC:  BTFSC  25.0
18AE:  MOVLW  01
18B0:  MOVLB  4
18B2:  MOVWF  x46
18B4:  MOVFF  24,448
18B8:  MOVFF  23,447
18BC:  MOVWF  x49
18BE:  MOVLB  0
18C0:  RCALL  1794
....................                     step =1;
18C2:  MOVLW  01
18C4:  MOVWF  31
....................                     break;
18C6:  BRA    193C
....................               case 1: 
....................                     if(nowdcmotor.duty!= dcmotor.duty)
18C8:  MOVF   23,W
18CA:  SUBWF  28,W
18CC:  BNZ   18D4
18CE:  MOVF   24,W
18D0:  SUBWF  29,W
18D2:  BZ    18EE
....................                        DCMOTOR_MIDDLELEVEL_CONTROL(dcmotor.duty,dcmotor.direct) ;
18D4:  MOVLW  00
18D6:  BTFSC  25.0
18D8:  MOVLW  01
18DA:  MOVLB  4
18DC:  MOVWF  x46
18DE:  MOVFF  24,448
18E2:  MOVFF  23,447
18E6:  MOVWF  x49
18E8:  MOVLB  0
18EA:  RCALL  1794
18EC:  BRA    18FA
....................                     else if(nowdcmotor.direct!= dcmotor.direct) step=2;
18EE:  MOVF   2A,W
18F0:  XORWF  25,W
18F2:  ANDLW  01
18F4:  BZ    18FA
18F6:  MOVLW  02
18F8:  MOVWF  31
....................                     break;
18FA:  BRA    193C
....................               case 2:                                    // Giam toc tu tu
....................                     if(DCMOTOR_MIDDLELEVEL_CONTROL(0,nowdcmotor.direct)==OK) step=3;
18FC:  MOVLW  00
18FE:  BTFSC  2A.0
1900:  MOVLW  01
1902:  MOVLB  4
1904:  MOVWF  x46
1906:  CLRF   x48
1908:  CLRF   x47
190A:  MOVWF  x49
190C:  MOVLB  0
190E:  RCALL  1794
1910:  MOVF   01,F
1912:  BNZ   1918
1914:  MOVLW  03
1916:  MOVWF  31
....................                     break;
1918:  BRA    193C
....................               case 3:                                     // Tang toc tu tu
....................                     if(DCMOTOR_MIDDLELEVEL_CONTROL(dcmotor.duty,!nowdcmotor.direct)==OK) 
191A:  MOVLW  00
191C:  BTFSS  2A.0
191E:  MOVLW  01
1920:  MOVLB  4
1922:  MOVWF  x46
1924:  MOVFF  24,448
1928:  MOVFF  23,447
192C:  MOVWF  x49
192E:  MOVLB  0
1930:  RCALL  1794
1932:  MOVF   01,F
1934:  BNZ   193C
....................                     {
....................                         nowdcmotor.direct = !nowdcmotor.direct;
1936:  BTG    2A.0
....................                         step=1;
1938:  MOVLW  01
193A:  MOVWF  31
....................                     }
....................                     break;       
....................         }
....................         return OK;
193C:  MOVLW  00
193E:  MOVWF  01
1940:  GOTO   1D1A (RETURN)
.................... }
.................... result dcmotor_read_speed()
.................... {
....................       static int1 tt_init=0;
....................       static int8 step=0;
....................       static unsigned int32 t;
....................       if(tt_init==0)
*
19C4:  BTFSC  32.0
19C6:  BRA    19CE
....................         {
....................             setup_timer_1(t1_external_sync|t1_div_by_1);  // TIMER 1 dem xung tu encoder
19C8:  MOVLW  83
19CA:  MOVWF  FCD
....................             tt_init=1;
19CC:  BSF    32.0
....................         }
....................       switch (step)
19CE:  MOVF   33,W
19D0:  BZ    19D8
19D2:  XORLW  01
19D4:  BZ    19F2
19D6:  BRA    1AA2
....................       {
....................             case 0:
....................                   set_timer1(0);
19D8:  CLRF   FCF
19DA:  CLRF   FCE
19DC:  NOP   
....................                   t = delay_start(); 
19DE:  RCALL  13FE
19E0:  CLRF   37
19E2:  CLRF   36
19E4:  MOVFF  02,35
19E8:  MOVFF  01,34
....................                   step=1;
19EC:  MOVLW  01
19EE:  MOVWF  33
....................                   break;
19F0:  BRA    1AA2
....................             case 1:
....................                   if(delay_stop(t)>=100)
19F2:  MOVFF  35,44E
19F6:  MOVFF  34,44D
19FA:  RCALL  1454
19FC:  MOVFF  02,447
1A00:  MOVFF  01,446
1A04:  MOVLB  4
1A06:  MOVF   x47,F
1A08:  BNZ   1A10
1A0A:  MOVF   x46,W
1A0C:  SUBLW  63
1A0E:  BC    1AA0
....................                    {
....................                       dcmotor.speed = (int32)SPEEDMUL*get_timer1()/delay_stop(t);
1A10:  MOVF   FCE,W
1A12:  MOVFF  FCF,03
1A16:  MOVWF  x46
1A18:  MOVFF  FCF,447
1A1C:  CLRF   x4B
1A1E:  CLRF   x4A
1A20:  MOVLW  05
1A22:  MOVWF  x49
1A24:  MOVLW  35
1A26:  MOVWF  x48
1A28:  CLRF   x4F
1A2A:  CLRF   x4E
1A2C:  MOVFF  FCF,44D
1A30:  MOVFF  446,44C
1A34:  MOVLB  0
1A36:  BRA    1966
1A38:  MOVFF  03,449
1A3C:  MOVFF  02,448
1A40:  MOVFF  01,447
1A44:  MOVFF  00,446
1A48:  MOVFF  35,44E
1A4C:  MOVFF  34,44D
1A50:  RCALL  1454
1A52:  MOVFF  02,44B
1A56:  MOVLB  4
1A58:  MOVFF  01,44A
1A5C:  MOVFF  FEA,44D
1A60:  MOVFF  FE9,44C
1A64:  BCF    FD8.1
1A66:  MOVFF  449,454
1A6A:  MOVFF  448,453
1A6E:  MOVFF  447,452
1A72:  MOVFF  446,451
1A76:  CLRF   x58
1A78:  CLRF   x57
1A7A:  MOVFF  02,456
1A7E:  MOVFF  01,455
1A82:  MOVLB  0
1A84:  RCALL  136A
1A86:  MOVFF  44D,FEA
1A8A:  MOVFF  44C,FE9
1A8E:  MOVFF  01,27
1A92:  MOVFF  00,26
....................                       step=0;
1A96:  CLRF   33
....................                       return OK;
1A98:  MOVLW  00
1A9A:  MOVWF  01
1A9C:  BRA    1AA6
1A9E:  MOVLB  4
....................                    }
....................                   break;
1AA0:  MOVLB  0
....................       }
....................       return BUSY;
1AA2:  MOVLW  02
1AA4:  MOVWF  01
1AA6:  GOTO   1D1C (RETURN)
.................... }
.................... #endif
.................... 
.................... #include<tv_glcd.c>
.................... #ifndef  __TV_GLCD_C__
.................... #define  __TV_GLCD_C__
.................... #include<tv_glcd.h>
.................... #ifndef __TV_GLCD_H__
.................... #define __TV_GLCD_H__
.................... #if  BOARD == MOPHONG
....................    #define GLCD_WIDTH           192
....................    #define GLCD_HIGH            64
....................    typedef struct 
....................    { 
....................      int8 x;
....................      int8 y;
....................      int8 size;
....................      int1 mau  ;
....................      int1 tt_text;
....................      int1 tt_update;
....................      int1 overlay  ;
....................      unsigned int8 x1;
....................      unsigned int8 y1;
....................      unsigned int8 x2;
....................      unsigned int8 y2;
....................      int8 displayData[8][192];
....................    } GLCD_STRUCT;    
....................    GLCD_STRUCT GLCD;
.................... #else 
....................    #DEFINE GLCD_NGANG              16 //256 PIXEL
....................    #DEFINE GLCD_DOC                32 //32 HANG
....................    #DEFINE GLCD_WIDTH              128 //DANH CHO THU VIEN GRAPHIC.C
....................    typedef union 
....................    { 
....................      unsigned int16 word; 
....................      unsigned int8 nbyte[2]; 
....................    } GLCD_DOTS; 
....................    
....................    typedef struct 
....................    { 
....................      int8 x;
....................      int8 y;
....................      int8 size;
....................      int1 mau  ;
....................      int1 tt_text;
....................      int1 tt_update;
....................      int1 overlay;
....................      unsigned int8 x1;
....................      unsigned int8 y1;
....................      unsigned int8 x2;
....................      unsigned int8 y2;
....................      GLCD_DOTS PIXEL[GLCD_DOC][GLCD_NGANG]; 
....................    } GLCD_VAR_STRUCT;    
....................    GLCD_VAR_STRUCT GLCD;
.................... #endif
.................... 
.................... result glcd_command(int8 data);
.................... result glcd_data(int8 data);
.................... result glcd_setup(void);
.................... result glcd_clear(int1 color);
.................... result glcd_text_setup(unsigned int16 x, unsigned int16 y,int8 size, int1 color,int1 overlay);
.................... result glcd_text(int8 t);
.................... result glcd_pixel(unsigned int8 x, unsigned int8 y, int1 color);
.................... result glcd_line(unsigned int8 x1, unsigned int8 y1, unsigned int8 x2, unsigned int8 y2, int1 color);
.................... result glcd_bar(unsigned int8 x1, unsigned int8 y1, unsigned int8 x2, unsigned int8 y2, unsigned int8 width, int1 color);
.................... result glcd_rect(unsigned int8 x1, unsigned int8 y1, unsigned int8 x2, unsigned int8 y2, int1 fill, int1 color);
.................... result glcd_circle(unsigned int8 x, unsigned int8 y, unsigned int8 radius, int1 fill, int1 color);
.................... result glcd_triangle(signed int16 x1,signed int16 y1, signed int16 x2, signed int16 y2, signed int16 x3, signed int16 y3,int1 fill,int1 color);
.................... result glcd_spkt_logo_raw(int x) ;
.................... result glcd_update(void);
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx FONT xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... const unsigned int8 GLCD_FONT[51][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE
....................                          0x00, 0x00, 0x5F, 0x00, 0x00, // !
....................                          0x00, 0x03, 0x00, 0x03, 0x00, // "
....................                          0x14, 0x3E, 0x14, 0x3E, 0x14, // #
....................                          0x24, 0x2A, 0x7F, 0x2A, 0x12, // $
....................                          0x43, 0x33, 0x08, 0x66, 0x61, // %
....................                          0x36, 0x49, 0x55, 0x22, 0x50, // &
....................                          0x00, 0x05, 0x03, 0x00, 0x00, // '
....................                          0x00, 0x1C, 0x22, 0x41, 0x00, // (
....................                          0x00, 0x41, 0x22, 0x1C, 0x00, // )
....................                          0x14, 0x08, 0x3E, 0x08, 0x14, // *
....................                          0x08, 0x08, 0x3E, 0x08, 0x08, // +
....................                          0x00, 0x50, 0x30, 0x00, 0x00, // ,
....................                          0x08, 0x08, 0x08, 0x08, 0x08, // -
....................                          0x00, 0x60, 0x60, 0x00, 0x00, // .
....................                          0x20, 0x10, 0x08, 0x04, 0x02, // /
....................                          0x3E, 0x51, 0x49, 0x45, 0x3E, // 0
....................                          0x00, 0x04, 0x02, 0x7F, 0x00, // 1
....................                          0x42, 0x61, 0x51, 0x49, 0x46, // 2
....................                          0x22, 0x41, 0x49, 0x49, 0x36, // 3
....................                          0x18, 0x14, 0x12, 0x7F, 0x10, // 4
....................                          0x27, 0x45, 0x45, 0x45, 0x39, // 5
....................                          0x3E, 0x49, 0x49, 0x49, 0x32, // 6
....................                          0x01, 0x01, 0x71, 0x09, 0x07, // 7
....................                          0x36, 0x49, 0x49, 0x49, 0x36, // 8
....................                          0x26, 0x49, 0x49, 0x49, 0x3E, // 9
....................                          0x00, 0x36, 0x36, 0x00, 0x00, // :
....................                          0x00, 0x56, 0x36, 0x00, 0x00, // ;
....................                          0x08, 0x14, 0x22, 0x41, 0x00, // <
....................                          0x14, 0x14, 0x14, 0x14, 0x14, // =
....................                          0x00, 0x41, 0x22, 0x14, 0x08, // >
....................                          0x02, 0x01, 0x51, 0x09, 0x06, // ?
....................                          0x3E, 0x41, 0x59, 0x55, 0x5E, // @
....................                          0x7E, 0x09, 0x09, 0x09, 0x7E, // A
....................                          0x7F, 0x49, 0x49, 0x49, 0x36, // B
....................                          0x3E, 0x41, 0x41, 0x41, 0x22, // C
....................                          0x7F, 0x41, 0x41, 0x41, 0x3E, // D
....................                          0x7F, 0x49, 0x49, 0x49, 0x41, // E
....................                          0x7F, 0x09, 0x09, 0x09, 0x01, // F
....................                          0x3E, 0x41, 0x41, 0x49, 0x3A, // G
....................                          0x7F, 0x08, 0x08, 0x08, 0x7F, // H
....................                          0x00, 0x41, 0x7F, 0x41, 0x00, // I
....................                          0x30, 0x40, 0x40, 0x40, 0x3F, // J
....................                          0x7F, 0x08, 0x14, 0x22, 0x41, // K
....................                          0x7F, 0x40, 0x40, 0x40, 0x40, // L
....................                          0x7F, 0x02, 0x0C, 0x02, 0x7F, // M
....................                          0x7F, 0x02, 0x04, 0x08, 0x7F, // N
....................                          0x3E, 0x41, 0x41, 0x41, 0x3E, // O
....................                          0x7F, 0x09, 0x09, 0x09, 0x06, // P
....................                          0x1E, 0x21, 0x21, 0x21, 0x5E, // Q
....................                          0x7F, 0x09, 0x09, 0x09, 0x76};// R
.................... const unsigned int8 GLCD_FONT2[44][5]={0x26, 0x49, 0x49, 0x49, 0x32, // S
....................                          0x01, 0x01, 0x7F, 0x01, 0x01, // T
....................                          0x3F, 0x40, 0x40, 0x40, 0x3F, // U
....................                          0x1F, 0x20, 0x40, 0x20, 0x1F, // V
....................                          0x7F, 0x20, 0x10, 0x20, 0x7F, // W
....................                          0x41, 0x22, 0x1C, 0x22, 0x41, // X
....................                          0x07, 0x08, 0x70, 0x08, 0x07, // Y
....................                          0x61, 0x51, 0x49, 0x45, 0x43, // Z
....................                          0x00, 0x7F, 0x41, 0x00, 0x00, // [
....................                          0x02, 0x04, 0x08, 0x10, 0x20, // \
....................                          0x00, 0x00, 0x41, 0x7F, 0x00, // ]
....................                          0x04, 0x02, 0x01, 0x02, 0x04, // ^
....................                          0x40, 0x40, 0x40, 0x40, 0x40, // _
....................                          0x00, 0x01, 0x02, 0x04, 0x00, // `
....................                          0x20, 0x54, 0x54, 0x54, 0x78, // a
....................                          0x7F, 0x44, 0x44, 0x44, 0x38, // b
....................                          0x38, 0x44, 0x44, 0x44, 0x44, // c
....................                          0x38, 0x44, 0x44, 0x44, 0x7F, // d
....................                          0x38, 0x54, 0x54, 0x54, 0x18, // e
....................                          0x04, 0x04, 0x7E, 0x05, 0x05, // f
....................                          0x08, 0x54, 0x54, 0x54, 0x3C, // g
....................                          0x7F, 0x08, 0x04, 0x04, 0x78, // h
....................                          0x00, 0x44, 0x7D, 0x40, 0x00, // i
....................                          0x20, 0x40, 0x44, 0x3D, 0x00, // j
....................                          0x7F, 0x10, 0x28, 0x44, 0x00, // k
....................                          0x00, 0x41, 0x7F, 0x40, 0x00, // l
....................                          0x7C, 0x04, 0x78, 0x04, 0x78, // m
....................                          0x7C, 0x08, 0x04, 0x04, 0x78, // n
....................                          0x38, 0x44, 0x44, 0x44, 0x38, // o
....................                          0x7C, 0x14, 0x14, 0x14, 0x08, // p
....................                          0x08, 0x14, 0x14, 0x14, 0x7C, // q
....................                          0x00, 0x7C, 0x08, 0x04, 0x04, // r
....................                          0x48, 0x54, 0x54, 0x54, 0x20, // s
....................                          0x04, 0x04, 0x3F, 0x44, 0x44, // t
....................                          0x3C, 0x40, 0x40, 0x20, 0x7C, // u
....................                          0x1C, 0x20, 0x40, 0x20, 0x1C, // v
....................                          0x3C, 0x40, 0x30, 0x40, 0x3C, // w
....................                          0x44, 0x28, 0x10, 0x28, 0x44, // x
....................                          0x0C, 0x50, 0x50, 0x50, 0x3C, // y
....................                          0x44, 0x64, 0x54, 0x4C, 0x44, // z
....................                          0x00, 0x08, 0x36, 0x41, 0x41, // {
....................                          0x00, 0x00, 0x7F, 0x00, 0x00, // |
....................                          0x41, 0x41, 0x36, 0x08, 0x00, // }
....................                          0x02, 0x01, 0x02, 0x04, 0x02};// ~
.................... const unsigned int8 GLCD_Logo_DHSPKTTP [] = {
....................                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
....................                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00,
....................                         0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00,
....................                         0x00, 0x00, 0x00, 0x07, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xA0, 0x00, 0x00, 0x00,
....................                         0x00, 0x00, 0x00, 0x03, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x20, 0x00, 0x00, 0x00,
....................                         0x00, 0x00, 0x00, 0x02, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x30, 0x00, 0x00, 0x00,
....................                         0x00, 0x00, 0x00, 0x02, 0x30, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x30, 0x00, 0x7E, 0x00,
....................                         0x00, 0xFE, 0x00, 0x07, 0xE0, 0x00, 0x3F, 0x00, 0x01, 0xF8, 0x00, 0x03, 0xE0, 0x00, 0x1F, 0x80,
....................                         0x03, 0xF0, 0x00, 0x01, 0xC0, 0x00, 0x0F, 0xC0, 0x03, 0xE0, 0x00, 0x01, 0xC0, 0x00, 0x07, 0xE0,
....................                         0x07, 0xC0, 0x00, 0x03, 0xC0, 0x00, 0x03, 0xF0, 0x0F, 0xC0, 0x00, 0x17, 0xF4, 0x00, 0x01, 0xF0,
....................                         0x0F, 0x80, 0x00, 0x1D, 0x98, 0x00, 0x00, 0xF8, 0x1F, 0x00, 0x00, 0x11, 0x8C, 0x00, 0x00, 0xF8,
....................                         0x1F, 0x01, 0x00, 0x31, 0x84, 0x00, 0x80, 0x7C, 0x3E, 0x06, 0x00, 0x31, 0x86, 0x00, 0x20, 0x7C,
....................                         0x3E, 0x18, 0x00, 0x71, 0x86, 0x00, 0x1C, 0x3E, 0x3C, 0x43, 0x00, 0x31, 0x84, 0x00, 0xC3, 0x3E,
....................                         0x7C, 0x0C, 0x00, 0x11, 0x8C, 0x00, 0x38, 0x1E, 0x7C, 0x31, 0x00, 0x1D, 0x98, 0x00, 0x86, 0x1F,
....................                         0x78, 0xC6, 0x00, 0x1F, 0xFC, 0x00, 0x63, 0x1F, 0x78, 0x18, 0x00, 0x03, 0xC0, 0x00, 0x0C, 0x1F,
....................                         0xF8, 0x63, 0x80, 0x01, 0x80, 0x00, 0xC7, 0x0F, 0xF9, 0x8E, 0x00, 0x00, 0x00, 0x00, 0x38, 0x8F,
....................                         0xF8, 0x38, 0x80, 0x00, 0x00, 0x01, 0x0C, 0x0F, 0xF8, 0xC3, 0x80, 0x00, 0x00, 0x00, 0xE3, 0x8F,
....................                         0xF9, 0x8E, 0x00, 0x00, 0x00, 0x00, 0x30, 0xCF, 0xF8, 0x38, 0xF8, 0x00, 0x00, 0x1F, 0x9E, 0x0F,
....................                         0xF8, 0xE3, 0xFE, 0x00, 0x00, 0x7F, 0xE3, 0x8F, 0xF9, 0x9F, 0xFF, 0xC0, 0x03, 0xFF, 0xF9, 0xCF,
....................                         0x78, 0xFF, 0xFF, 0xE0, 0x07, 0xFF, 0xFF, 0x0F, 0x78, 0x1F, 0xFF, 0xE0, 0x07, 0xFF, 0xFC, 0x1F,
....................                         0x7C, 0x07, 0xFF, 0xE0, 0x07, 0xFF, 0xE0, 0x1F, 0x7C, 0x00, 0xFF, 0xE0, 0x07, 0xFF, 0x80, 0x1E,
....................                         0x7C, 0x00, 0x1F, 0xE0, 0x07, 0xFC, 0x00, 0x3E, 0x3E, 0x01, 0xCF, 0xE0, 0x07, 0xF3, 0x80, 0x3E,
....................                         0x3E, 0x01, 0xFF, 0xE0, 0x03, 0xFF, 0x80, 0x7C, 0x1F, 0x01, 0xFF, 0xE0, 0x03, 0xFF, 0xC0, 0x7C,
....................                         0x1F, 0x01, 0xFF, 0xC0, 0x03, 0xFF, 0xC0, 0xF8, 0x0F, 0x83, 0xFF, 0xC0, 0x01, 0xFF, 0xC0, 0xF8,
....................                         0x0F, 0x83, 0xFF, 0xC0, 0x01, 0xFF, 0xC1, 0xF0, 0x07, 0xC3, 0xFF, 0x80, 0x01, 0xFF, 0xE3, 0xF0,
....................                         0x03, 0xE3, 0xFF, 0x80, 0x01, 0xFF, 0xE7, 0xE0, 0x03, 0xF7, 0xFF, 0x80, 0x00, 0xFF, 0xEF, 0xC0,
....................                         0x01, 0xFF, 0xFF, 0x80, 0x00, 0xFF, 0xFF, 0x80, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x80,
....................                         0x00, 0x7F, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x3F, 0xFF, 0x00, 0x00, 0xFF, 0xFE, 0x00,
....................                         0x00, 0x1F, 0xFF, 0x00, 0x00, 0x7F, 0xF8, 0x00, 0x00, 0x0F, 0xFE, 0x00, 0x00, 0x7F, 0xF0, 0x00,
....................                         0x00, 0x03, 0xFF, 0x00, 0x00, 0x7F, 0xE0, 0x00, 0x00, 0x00, 0xFF, 0xFC, 0x1F, 0xFF, 0x80, 0x00,
....................                         0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xF8, 0x00, 0x00,
....................                         0x00, 0x00, 0x01, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xF0, 0x00, 0x00, 0x00
....................                         };
.................... #endif
.................... 
.................... #if  BOARD == MOPHONG
.................... //************************************** Board Mo Phong ****************************************************
.................... result GLCD_UPDATE_COORDINATE(unsigned int8 x1,unsigned int8 y1, unsigned int8 x2, unsigned int8 y2)
.................... {
....................       if(GLCD.tt_update==0)
....................       {
....................             GLCD.x1 = x1;
....................             GLCD.x2 = x2;
....................             GLCD.y1 = y1;
....................             GLCD.y2 = y2;   
....................       }
....................       else
....................       {    
....................             if(x1<GLCD.x1) GLCD.x1=x1;
....................             if(x2>GLCD.x2) GLCD.x2=x2;
....................             if(y1<GLCD.y1) GLCD.y1=y1;
....................             if(y2>GLCD.y2) GLCD.y2=y2;   
....................       } 
....................       GLCD.tt_update=1;
....................       return OK;
.................... }
.................... result glcd_clear(int1 color)
.................... {
....................    unsigned int8 i, j,cl;
....................    if(color) cl =0xff;
....................    else      cl =0;
....................    for(i = 0; i < 8; ++i)
....................     for(j = 0; j < 192; ++j)
....................      GLCD.displayData[i][j]= cl; 
....................    GLCD.x1 = 0;
....................    GLCD.x2 = 191;
....................    GLCD.y1 = 0;
....................    GLCD.y2 = 63;  
....................    GLCD.tt_update=1;
....................    return OK;
.................... }
.................... result glcd_pixel(unsigned int8 x, unsigned int8 y, int1 color)
.................... {
....................    if(color)
....................       bit_set(GLCD.displayData[y/8][x], y%8);
....................    else
....................       bit_clear(GLCD.displayData[y/8][x], y%8);
....................    GLCD_UPDATE_COORDINATE(x,y, x, y);
....................    return OK;
.................... }
.................... 
.................... result GLCD_PIXEL_TEMP(unsigned int8 x, unsigned int8 y, int1 color)
.................... {
....................    if(color)
....................       bit_set(GLCD.displayData[y/8][x], y%8);
....................    else
....................       bit_clear(GLCD.displayData[y/8][x], y%8);
....................    return OK;
.................... }
.................... 
.................... result GLCD_VERTICAL_LINE(unsigned int8 x, unsigned int8 y1,unsigned int8 y2, int1 color)
.................... {
....................    unsigned int8 i,top,bot;
....................    top=y1/8; bot = y2/8;
....................    if (top==bot) 
....................    {
....................           if(color)     
....................                GLCD.displayData[top][x]= GLCD.displayData[top][x] | ((0xff<<(y1%8)) & (0xff>>(7-(y2%8))));   
....................           else 
....................                GLCD.displayData[top][x]= GLCD.displayData[top][x] &(~((0xff<<(y1%8)) & (0xff>>(7-(y2%8)))));
....................    }
....................    else 
....................    {
....................           if(color)
....................           {    
....................                GLCD.displayData[top][x]= GLCD.displayData[top][x] | (0xff<<(y1%8));
....................                GLCD.displayData[bot][x]= GLCD.displayData[bot][x] | (0xff>>(7-(y2%8)));
....................                for(i = top + 1; i < bot; i++) GLCD.displayData[i][x]=0xff;
....................           }
....................           else 
....................           {    
....................                GLCD.displayData[top][x]= GLCD.displayData[top][x] & (~(0xff<<(y1%8)));
....................                GLCD.displayData[bot][x]= GLCD.displayData[bot][x] & (~(0xff>>(7-(y2%8))));
....................                for(i = top + 1; i < bot; i++)GLCD.displayData[i][x]=0;
....................           } 
....................    }
....................    return OK;
.................... }
.................... result glcd_update()
.................... {
....................     unsigned int8 i, j;
....................     GLCD.y1=GLCD.y1/8;
....................     GLCD.y2=GLCD.y2/8;
....................     for(i = GLCD.y1; i <=GLCD.y2; i++)
....................     {  
....................          output_high(GLCD_CSA);
....................          output_high(GLCD_CSB);
....................          output_high(GLCD_CSC);
....................          if(GLCD.x1<64)
....................           {    output_low(GLCD_CSA);
....................                glcd_command(0x40 | GLCD.x1);
....................           }
....................          else if(GLCD.x1<128)
....................           {    output_low(GLCD_CSB);
....................                glcd_command(0x40 | (GLCD.x1-64));
....................           }
....................          else 
....................           {    output_low(GLCD_CSC);
....................                glcd_command(0x40 | (GLCD.x1-128));
....................           }  
....................          glcd_command(0xB8 | i);
....................          for (j=GLCD.x1;j<= GLCD.x2;j++)
....................          {
....................                if(j==64)      {output_high(GLCD_CSA);output_low(GLCD_CSB);glcd_command(0x40);glcd_command(0xB8 | i); }
....................                else if(j==128){output_high(GLCD_CSB);output_low(GLCD_CSC);glcd_command(0x40);glcd_command(0xB8 | i); }
....................                glcd_data(GLCD.displayData[i][j]);  
....................          }
....................     }
....................     GLCD.tt_update=0;
....................     return OK;
.................... }
.................... result glcd_text_setup(unsigned int16 x, unsigned int16 y,int8 size, int1 color,int1 overlay)
.................... {
....................       GLCD.mau = color;
....................       GLCD.size = size;
....................       GLCD.x    = x;
....................       GLCD.y    =y;
....................       GLCD.tt_text=0;
....................       GLCD.overlay=overlay;
....................       return OK;
.................... }
.................... 
.................... result glcd_text( char t)
.................... {      
....................       static unsigned int8 x1,x2,y1,y2;
....................       unsigned int8 j, k, l;                      
....................       unsigned int8 pixelData[5]; 
....................       if(GLCD.overlay)
....................       {
....................             glcd_rect(GLCD.x,GLCD.y,GLCD.x+6*GLCD.size,GLCD.y+7*GLCD.size,1,!GLCD.mau);
....................       }
....................       if(GLCD.tt_text==0)
....................       {
....................           x1=GLCD.x;
....................           y1=GLCD.y;
....................           GLCD.tt_text=1;
....................       }
....................       if(t < 'S')
....................          memcpy(pixelData, GLCD_FONT[t - ' '], 5);
....................       else if(t <= '~') 
....................          memcpy(pixelData, GLCD_FONT2[t - 'S'], 5);
....................       else
....................          memcpy(pixelData, GLCD_FONT[0], 5);   
....................       if(GLCD.x+5*GLCD.size >= GLCD_WIDTH)         
....................       {
....................          GLCD.x = 0;                           
....................          GLCD.y += 7*GLCD.size + 1;                 
....................       }
....................       for(j=0; j<5; ++j, GLCD.x+=GLCD.size)         
....................       {
....................          for(k=0; k < 7; ++k)             
....................          {
....................             if(bit_test(pixelData[j], k)) 
....................             {
....................                for(l=0; l < GLCD.size; ++l)   
....................                {   
....................                   GLCD_VERTICAL_LINE(GLCD.x+l, GLCD.y+k*GLCD.size,GLCD.y+(k+1)*GLCD.size-1, GLCD.mau);
....................                }
....................             }
....................          }
....................       }
....................       x2 = GLCD.x;
....................       GLCD.x+=GLCD.size;
....................       y2= GLCD.y + 7*GLCD.size;
....................       GLCD_UPDATE_COORDINATE(x1,y1, x2,y2);
....................       return OK;
....................  }
....................  
.................... 
.................... result glcd_spkt_logo_raw(int x) 
.................... { 
....................    unsigned int8 i=0, j=0, k=0,y=0; 
....................    unsigned int16 count=0; 
....................    GLCD_UPDATE_COORDINATE(x,0, x+64,63);
....................    for(j=0;j<64;j++) 
....................       {    
....................          for(;i<64;) 
....................          { 
....................             for(k=8;k>0;k--)
....................             {
....................                GLCD_PIXEL_TEMP(i+x,j+y,bit_test(GLCD_Logo_DHSPKTTP[count],(k-1))); 
....................                i++; 
....................             } 
....................             count++; 
....................          } 
....................       i=0; 
....................       } 
....................      return OK;
.................... } 
.................... 
.................... result glcd_line(unsigned int8 x1, unsigned int8 y1, unsigned int8 x2, unsigned int8 y2, int1 color)
.................... {
....................    unsigned int16        dy, dx;
....................    signed int8  addx=1, addy=1;
....................    signed int16 P, diff;
....................    unsigned int8 i=0,xt1,xt2,yt1,yt2;
....................    dx = abs((signed int8)(x2 - x1));
....................    dy = abs((signed int8)(y2 - y1));
....................    xt1=x1; xt2=x2;
....................    yt1=y1, yt2=y2;
....................    if(x1 > x2)
....................    {
....................       addx = -1;
....................       xt2=x1;
....................       xt1=x2;
....................    }
....................    if(y1 > y2)
....................    {
....................       addy = -1;
....................       yt2=y1;
....................       yt1=y2;
....................    }
....................    GLCD_UPDATE_COORDINATE(xt1,yt1, xt2,yt2);
....................    if(dx >= dy)
....................    {
....................       dy *= 2;
....................       P = dy - dx;
....................       diff = P - dx;
.................... 
....................       for(; i<=dx; ++i)
....................       {
....................          GLCD_PIXEL_TEMP(x1, y1, color);
.................... 
....................          if(P < 0)
....................          {
....................             P  += dy;
....................             x1 += addx;
....................          }
....................          else
....................          {
....................             P  += diff;
....................             x1 += addx;
....................             y1 += addy;
....................          }
....................       }
....................    }
....................    else
....................    {
....................       dx *= 2;
....................       P = dx - dy;
....................       diff = P - dy;
.................... 
....................       for(; i<=dy; ++i)
....................       {
....................          GLCD_PIXEL_TEMP(x1, y1, color);
.................... 
....................          if(P < 0)
....................          {
....................             P  += dx;
....................             y1 += addy;
....................          }
....................          else
....................          {
....................             P  += diff;
....................             x1 += addx;
....................             y1 += addy;
....................          }
....................       }
....................    }
....................    return OK;
.................... }
.................... result glcd_rect(unsigned int8 x1, unsigned int8 y1, unsigned int8 x2, unsigned int8 y2, int1 fill, int1 color)
.................... {
....................       unsigned int8  xmin, xmax, ymin, ymax,i;
....................       xmin = x1;
....................       xmax = x2;
....................       ymin = y1;
....................       ymax = y2;
....................       if(x1 > x2)                            
....................       {
....................          xmin = x2;
....................          xmax = x1;
....................       }
....................       if(y1 > y2)                           
....................       {
....................          ymin = y2;
....................          ymax = y1;
....................       }
....................       if(fill)
....................       {
....................          for(i=xmin; i <= xmax; i++)
....................             GLCD_VERTICAL_LINE(i, ymin,ymax,color);
....................       }
....................       else
....................       {
....................          GLCD_VERTICAL_LINE(xmin, ymin,ymax, color);
....................          GLCD_VERTICAL_LINE(xmax, ymin,ymax, color);
....................          glcd_line(x1, y1, x2, y1, color);      // Draw the 4 sides
....................          glcd_line(x1, y2, x2, y2, color);
....................       }
....................       GLCD_UPDATE_COORDINATE(xmin,ymin, xmax,ymax);
....................       return OK;
.................... }
.................... 
.................... result glcd_bar(unsigned int8 x1, unsigned int8 y1, unsigned int8 x2, unsigned int8 y2, unsigned int8 width, int1 color)
.................... {
....................    unsigned int8         half_width;
....................    signed int16 dy, dx;
....................    signed int8  addx=1, addy=1, j;
....................    signed int16 P, diff, c1, c2;
....................    unsigned int8 i=0,xt1,yt1,xt2,yt2;
....................    dx = abs((signed int8)(x2 - x1));
....................    dy = abs((signed int8)(y2 - y1));
....................    half_width = width/2;
....................    c1 = -(dx*x1 + dy*y1);
....................    c2 = -(dx*x2 + dy*y2);  
....................    xt1=x1-half_width;
....................    xt2=x2+half_width;
....................    yt1=y1-half_width;
....................    yt2=y2+half_width;
....................    if(x1 > x2)
....................    {
....................       signed int16 temp;
....................       temp = c1;
....................       c1 = c2;
....................       c2 = temp;
....................       addx = -1;
....................       xt1=x2-half_width;
....................       xt2=x1+half_width;  
....................    }
....................    if(y1 > y2)
....................    {
....................       signed int16 temp;
....................       temp = c1;
....................       c1 = c2;
....................       c2 = temp;
....................       addy = -1;
....................       yt1=y2-half_width;
....................       yt2=y1+half_width;
....................    }
....................    if(xt1>191)  xt1=0;
....................    if(yt1>191)  yt1=0;
....................    if(xt2>191)  xt2=191;
....................    if(yt2>63)   yt2=63;
....................    GLCD_UPDATE_COORDINATE(xt1,yt1, xt2,yt2);
....................    if(dx >= dy)
....................    {
....................       P = 2*dy - dx;
....................       diff = P - dx;
.................... 
....................       for(i=0; i<=dx; ++i)
....................       {
....................          for(j=-half_width; j<half_width+width%2; ++j)
....................          {
....................                GLCD_PIXEL_TEMP(x1, y1+j, color);
....................          }
....................          if(P < 0)
....................          {
....................             P  += 2*dy;
....................             x1 += addx;
....................          }
....................          else
....................          {
....................             P  += diff;
....................             x1 += addx;
....................             y1 += addy;
....................          }
....................       }
....................    }
....................    else
....................    {
....................       P = 2*dx - dy;
....................       diff = P - dy;
.................... 
....................       for(i=0; i<=dy; ++i)
....................       {
....................          if(P < 0)
....................          {
....................             P  += 2*dx;
....................             y1 += addy;
....................          }
....................          else
....................          {
....................             P  += diff;
....................             x1 += addx;
....................             y1 += addy;
....................          }
....................          for(j=-half_width; j<half_width+width%2; ++j)
....................          {
....................                GLCD_PIXEL_TEMP(x1+j, y1, color);
....................          }
....................       }
....................    }
....................    return OK;
.................... }
.................... 
.................... result glcd_circle(unsigned int8 x, unsigned int8 y, unsigned int8 radius, int1 fill, int1 color)
.................... {
....................    unsigned int8 xt1,xt2, yt1, yt2;
....................    signed int8  a, b, P;
....................    a = 0;
....................    b = radius;
....................    P = 1 - radius;
....................    do
....................    {
....................       if(fill)
....................       {
....................           GLCD_VERTICAL_LINE(x+b, y-a,y+a, color);
....................           GLCD_VERTICAL_LINE(x-b, y-a,y+a, color);
....................           GLCD_VERTICAL_LINE(x+a, y-b,y+b, color);
....................           GLCD_VERTICAL_LINE(x-a, y-b,y+b, color);
....................       }
....................       else
....................       {
....................          GLCD_PIXEL_TEMP(a+x, b+y, color);
....................          GLCD_PIXEL_TEMP(b+x, a+y, color);
....................          GLCD_PIXEL_TEMP(x-a, b+y, color);
....................          GLCD_PIXEL_TEMP(x-b, a+y, color);
....................          GLCD_PIXEL_TEMP(b+x, y-a, color);
....................          GLCD_PIXEL_TEMP(a+x, y-b, color);
....................          GLCD_PIXEL_TEMP(x-a, y-b, color);
....................          GLCD_PIXEL_TEMP(x-b, y-a, color);
....................       }
.................... 
....................       if(P < 0)
....................          P += 3 + 2 * a++;
....................       else
....................          P += 5 + 2 * (a++ - b--);
....................     } while(a <= b);
....................     xt1 = x-radius;
....................     xt2 = x+radius;
....................     yt1 = y-radius;
....................     yt2 = y+radius;
....................     if(xt1>191)   xt1=0;
....................     if(yt1>191)   yt1=0;
....................     if(xt2>191)   xt2=191;
....................     if(yt2>63)    yt2=63;
....................     GLCD_UPDATE_COORDINATE(xt1,yt1, xt2,yt2);
....................     return OK;
.................... }
.................... result glcd_triangle(signed int16 x1,signed int16 y1, signed int16 x2, signed int16 y2, signed int16 x3, signed int16 y3,int1 fill,int1 color)
.................... {
....................     unsigned int8 xt1, xt2, yt11,yt22;
....................     signed int16 x[3],y[3],n,yt1,yt2,yt,dx1,dx2,dx3,dy1,dy2,dy3; 
....................     signed int16 sh1,sh2,sh3;
....................     x[0]=x1; x[1]=x2; x[2]=x3;y[0]=y1; y[1]=y2; y[2]=y3;
....................     if(x[0]>x[1]){yt=x[0];x[0]=x[1];x[1]=yt;yt=y[0];y[0]=y[1];y[1]=yt;}
....................     if(x[0]>x[2]){yt=x[0];x[0]=x[2];x[2]=yt;yt=y[0];y[0]=y[2];y[2]=yt;}
....................     if(x[1]>x[2]){yt=x[1];x[1]=x[2];x[2]=yt;yt=y[1];y[1]=y[2];y[2]=yt;}
....................     dx1= x[2]-x[0]; dx2= x[1]-x[0];dx3=x[2]-x[1];
....................     dy1= y[2]-y[0]; dy2= y[1]-y[0];dy3=y[2]-y[1];
....................     sh1=x[2]*y[0] - x[0]*y[2]; sh2=x[1]*y[0] - x[0]*y[1]; sh3=x[2]*y[1] - x[1]*y[2];
....................     if(fill)
....................     {
....................         for(n=x[0] ; n<x[1]; n++)
....................           {
....................               yt1= (dy1*n + sh1)/dx1;
....................               yt2= (dy2*n + sh2)/dx2;
....................               if(yt2<yt1){yt= yt1; yt1=yt2; yt2=yt;}
....................               GLCD_VERTICAL_LINE(n,yt1,yt2,color);
....................           }
....................           for(n=x[1] ; n<x[2]; n++)
....................           {
....................               yt1= (dy1*n + sh1)/dx1;
....................               yt2= (dy3*n + sh3)/dx3;
....................               if(yt2<yt1){yt= yt1; yt1=yt2; yt2=yt;}
....................               GLCD_VERTICAL_LINE(n,yt1,yt2,color);
....................           }  
....................     }
....................     else 
....................     {
....................          glcd_line(x1,y1,x2,y2,color);
....................          glcd_line(x1,y1,x3,y3,color);
....................          glcd_line(x2,y2,x3,y3,color);
....................     }
....................     xt1 = x[0];
....................     xt2 = x[2];
....................     if(y[0]>y[1])yt22= y[0]; else yt22 = y[1];
....................     if(yt22<y[2]) yt22 = y[2]; 
....................     if(y[0]<y[1]) yt11= y[0]; else yt11 = y[1];
....................     if(yt11>y[2])yt11 = y[2];
....................     GLCD_UPDATE_COORDINATE(xt1,yt11, xt2,yt22); 
....................     return OK;
.................... }
.................... result glcd_data(int8 data)
.................... {
....................    output_high(glcd_rs);
....................    output_glcd(data);             
....................    output_high(glcd_e);     
....................    output_low(glcd_e);  
....................    delay_cycles(4);
....................    return OK;
.................... }
.................... result glcd_command(int8 data)
.................... {
....................    output_low(glcd_rs);
....................    output_glcd(data);             
....................    output_high(glcd_e);     
....................    output_low(glcd_e);  
....................    delay_us(4);
....................    return OK;
.................... }
.................... result glcd_setup()
.................... {
....................    output_low(GLCD_CSA);
....................    output_low(GLCD_CSB);
....................    output_low(GLCD_CSC);
....................    glcd_command(0x3F);
....................    glcd_clear(0);
....................    glcd_update();
....................    output_high(GLCD_CSA);
....................    output_high(GLCD_CSB);
....................    output_high(GLCD_CSC);
....................    GLCD.tt_text=1;
....................    GLCD.tt_update=0;
....................    return OK;
.................... }
.................... /**********************************************Board Thuc  Hanh******************************************/
.................... #else
.................... result GLCD_UPDATE_COORDINATE(unsigned int8 x1,unsigned int8 y1, unsigned int8 x2, unsigned int8 y2)
.................... {
....................       if(GLCD.tt_update==0)
*
0E7E:  BTFSC  3B.2
0E80:  BRA    0E94
....................       {
....................             GLCD.x1 = x1;
0E82:  MOVFF  469,3C
....................             GLCD.x2 = x2;
0E86:  MOVFF  46B,3E
....................             GLCD.y1 = y1;
0E8A:  MOVFF  46A,3D
....................             GLCD.y2 = y2;   
0E8E:  MOVFF  46C,3F
....................       }
0E92:  BRA    0EC0
....................       else
....................       {    
....................             if(x1<GLCD.x1) GLCD.x1=x1;
0E94:  MOVF   3C,W
0E96:  MOVLB  4
0E98:  SUBWF  x69,W
0E9A:  BTFSS  FD8.0
0E9C:  MOVFF  469,3C
....................             if(x2>GLCD.x2) GLCD.x2=x2;
0EA0:  MOVF   x6B,W
0EA2:  SUBWF  3E,W
0EA4:  BTFSS  FD8.0
0EA6:  MOVFF  46B,3E
....................             if(y1<GLCD.y1) GLCD.y1=y1;
0EAA:  MOVF   3D,W
0EAC:  SUBWF  x6A,W
0EAE:  BTFSS  FD8.0
0EB0:  MOVFF  46A,3D
....................             if(y2>GLCD.y2) GLCD.y2=y2;   
0EB4:  MOVF   x6C,W
0EB6:  SUBWF  3F,W
0EB8:  BTFSS  FD8.0
0EBA:  MOVFF  46C,3F
0EBE:  MOVLB  0
....................       } 
....................       GLCD.tt_update=1;
0EC0:  BSF    3B.2
....................       return OK;
0EC2:  MOVLW  00
0EC4:  MOVWF  01
0EC6:  RETURN 0
.................... }
.................... result glcd_clear(int1 color)
.................... {  
....................   int16 d,doc,ngang; 
....................   if(color)  d=0xffff; else d=0;
*
04EE:  MOVLB  4
04F0:  MOVF   x46,F
04F2:  BZ    04FA
04F4:  SETF   x48
04F6:  SETF   x47
04F8:  BRA    04FE
04FA:  CLRF   x48
04FC:  CLRF   x47
....................   for (DOC=0; DOC < GLCD_DOC; DOC++) 
04FE:  CLRF   x4A
0500:  CLRF   x49
0502:  MOVF   x4A,F
0504:  BNZ   057A
0506:  MOVF   x49,W
0508:  SUBLW  1F
050A:  BNC   057A
....................   { 
....................     for (NGANG=0; NGANG < GLCD_NGANG; NGANG++) 
050C:  CLRF   x4C
050E:  CLRF   x4B
0510:  MOVF   x4C,F
0512:  BNZ   0572
0514:  MOVF   x4B,W
0516:  SUBLW  0F
0518:  BNC   0572
....................     { 
....................       GLCD.PIXEL[DOC][NGANG].word = d; 
051A:  RLCF   x49,W
051C:  MOVWF  02
051E:  RLCF   x4A,W
0520:  MOVWF  03
0522:  RLCF   02,F
0524:  RLCF   03,F
0526:  RLCF   02,F
0528:  RLCF   03,F
052A:  RLCF   02,F
052C:  RLCF   03,F
052E:  RLCF   02,F
0530:  RLCF   03,F
0532:  MOVLW  E0
0534:  ANDWF  02,F
0536:  MOVF   02,W
0538:  ADDLW  08
053A:  MOVWF  x4D
053C:  MOVLW  00
053E:  ADDWFC 03,W
0540:  MOVWF  x4E
0542:  BCF    FD8.0
0544:  RLCF   x4B,W
0546:  MOVWF  02
0548:  RLCF   x4C,W
054A:  MOVWF  03
054C:  MOVF   02,W
054E:  ADDWF  x4D,F
0550:  MOVF   03,W
0552:  ADDWFC x4E,F
0554:  MOVLW  38
0556:  ADDWF  x4D,W
0558:  MOVWF  FE9
055A:  MOVLW  00
055C:  ADDWFC x4E,W
055E:  MOVWF  FEA
0560:  MOVFF  448,FEC
0564:  MOVF   FED,F
0566:  MOVFF  447,FEF
056A:  INCF   x4B,F
056C:  BTFSC  FD8.2
056E:  INCF   x4C,F
0570:  BRA    0510
....................     } 
0572:  INCF   x49,F
0574:  BTFSC  FD8.2
0576:  INCF   x4A,F
0578:  BRA    0502
....................   } 
....................    GLCD.x1 = 0;
057A:  CLRF   3C
....................    GLCD.x2 = 127;
057C:  MOVLW  7F
057E:  MOVWF  3E
....................    GLCD.y1 = 0;
0580:  CLRF   3D
....................    GLCD.y2 = 63;  
0582:  MOVLW  3F
0584:  MOVWF  3F
....................    GLCD.tt_update=1;
0586:  BSF    3B.2
....................    return OK;
0588:  MOVLW  00
058A:  MOVWF  01
058C:  MOVLB  0
058E:  GOTO   0754 (RETURN)
.................... } 
.................... 
.................... result glcd_pixel(int8 x, int8 y, int1 color) 
.................... { 
....................   int8  b,doc,ngang; 
....................   if(y>31){x += 128; y-= 32;}; 
....................   DOC = y; 
....................   NGANG = x/16; 
....................   b = 15 - (x % 16); 
....................   
....................   if (color == 1) bit_set (GLCD.PIXEL[DOC][NGANG].word, b); 
....................   else bit_clear (GLCD.PIXEL[DOC][NGANG].word, b); 
....................   GLCD_UPDATE_COORDINATE(x,y, x, y);
....................   return OK;
.................... } 
.................... result GLCD_PIXEL_TEMP(int8 x, int8 y, int1 color) 
.................... { 
....................   int8  b,doc,ngang; 
....................   if(y>31){x += 128; y-= 32;}; 
*
0D4A:  MOVLB  4
0D4C:  MOVF   x6F,W
0D4E:  SUBLW  1F
0D50:  BC    0D5A
0D52:  MOVLW  80
0D54:  ADDWF  x6E,F
0D56:  MOVLW  20
0D58:  SUBWF  x6F,F
....................   DOC = y; 
0D5A:  MOVFF  46F,472
....................   NGANG = x/16; 
0D5E:  SWAPF  x6E,W
0D60:  MOVWF  x73
0D62:  MOVLW  0F
0D64:  ANDWF  x73,F
....................   b = 15 - (x % 16); 
0D66:  MOVF   x6E,W
0D68:  ANDLW  0F
0D6A:  XORLW  FF
0D6C:  ADDLW  10
0D6E:  MOVWF  x71
....................   
....................   if (color == 1) bit_set (GLCD.PIXEL[DOC][NGANG].word, b); 
0D70:  DECFSZ x70,W
0D72:  BRA    0DDA
0D74:  CLRF   x76
0D76:  MOVFF  472,475
0D7A:  CLRF   x78
0D7C:  MOVLW  20
0D7E:  MOVWF  x77
0D80:  MOVLB  0
0D82:  RCALL  0592
0D84:  MOVF   01,W
0D86:  ADDLW  08
0D88:  MOVLB  4
0D8A:  MOVWF  x74
0D8C:  MOVLW  00
0D8E:  ADDWFC 02,W
0D90:  MOVWF  x75
0D92:  CLRF   03
0D94:  MOVFF  473,02
0D98:  BCF    FD8.0
0D9A:  RLCF   02,F
0D9C:  RLCF   03,F
0D9E:  MOVF   02,W
0DA0:  ADDWF  x74,F
0DA2:  MOVF   03,W
0DA4:  ADDWFC x75,F
0DA6:  MOVLW  38
0DA8:  ADDWF  x74,W
0DAA:  MOVWF  01
0DAC:  MOVLW  00
0DAE:  ADDWFC x75,W
0DB0:  MOVWF  03
0DB2:  MOVFF  01,FE9
0DB6:  MOVWF  FEA
0DB8:  CLRF   03
0DBA:  MOVLW  01
0DBC:  MOVWF  02
0DBE:  MOVF   x71,W
0DC0:  MOVWF  00
0DC2:  BZ    0DCE
0DC4:  BCF    FD8.0
0DC6:  RLCF   02,F
0DC8:  RLCF   03,F
0DCA:  DECFSZ 00,F
0DCC:  BRA    0DC4
0DCE:  MOVF   02,W
0DD0:  IORWF  FEF,F
0DD2:  MOVF   03,W
0DD4:  IORWF  FEC,W
0DD6:  MOVWF  FEF
0DD8:  BRA    0E4A
....................   else bit_clear (GLCD.PIXEL[DOC][NGANG].word, b); 
0DDA:  CLRF   x76
0DDC:  MOVFF  472,475
0DE0:  CLRF   x78
0DE2:  MOVLW  20
0DE4:  MOVWF  x77
0DE6:  MOVLB  0
0DE8:  CALL   0592
0DEC:  MOVF   01,W
0DEE:  ADDLW  08
0DF0:  MOVLB  4
0DF2:  MOVWF  x74
0DF4:  MOVLW  00
0DF6:  ADDWFC 02,W
0DF8:  MOVWF  x75
0DFA:  CLRF   03
0DFC:  MOVFF  473,02
0E00:  BCF    FD8.0
0E02:  RLCF   02,F
0E04:  RLCF   03,F
0E06:  MOVF   02,W
0E08:  ADDWF  x74,F
0E0A:  MOVF   03,W
0E0C:  ADDWFC x75,F
0E0E:  MOVLW  38
0E10:  ADDWF  x74,W
0E12:  MOVWF  01
0E14:  MOVLW  00
0E16:  ADDWFC x75,W
0E18:  MOVWF  03
0E1A:  MOVFF  01,FE9
0E1E:  MOVWF  FEA
0E20:  CLRF   03
0E22:  MOVLW  01
0E24:  MOVWF  02
0E26:  MOVF   x71,W
0E28:  MOVWF  00
0E2A:  BZ    0E36
0E2C:  BCF    FD8.0
0E2E:  RLCF   02,F
0E30:  RLCF   03,F
0E32:  DECFSZ 00,F
0E34:  BRA    0E2C
0E36:  MOVF   02,W
0E38:  XORLW  FF
0E3A:  MOVWF  00
0E3C:  MOVLW  FF
0E3E:  XORWF  03,F
0E40:  MOVF   00,W
0E42:  ANDWF  FEF,F
0E44:  MOVF   03,W
0E46:  ANDWF  FEC,W
0E48:  MOVWF  FEF
....................   return OK;
0E4A:  MOVLW  00
0E4C:  MOVWF  01
0E4E:  MOVLB  0
0E50:  GOTO   0E70 (RETURN)
.................... } 
.................... 
.................... result glcd_update ()
.................... {
....................   int8 hesox,hesox2,hesoy,doc,ngang; 
....................  // glcd_rect(GLCD.x1,GLCD.y1, GLCD.x2, GLCD.y2, 0,1);  
....................   if(GLCD.x1>GLCD.x2) {hesox=GLCD.x1; GLCD.x1=GLCD.x2, GLCD.x2= hesox;}
*
05E0:  MOVF   3C,W
05E2:  SUBWF  3E,W
05E4:  BC    05F2
05E6:  MOVFF  3C,446
05EA:  MOVFF  3E,3C
05EE:  MOVFF  446,3E
....................   if(GLCD.y1>GLCD.y2) {hesoy=GLCD.y1; GLCD.y1=GLCD.y2, GLCD.y2= hesoy;}
05F2:  MOVF   3D,W
05F4:  SUBWF  3F,W
05F6:  BC    0604
05F8:  MOVFF  3D,448
05FC:  MOVFF  3F,3D
0600:  MOVFF  448,3F
....................   if (GLCD.tt_update) 
0604:  BTFSS  3B.2
0606:  BRA    0714
....................   { 
....................       GLCD.x1 = GLCD.x1/16; GLCD.x2=GLCD.x2/16;
0608:  SWAPF  3C,F
060A:  MOVLW  0F
060C:  ANDWF  3C,F
060E:  SWAPF  3E,F
0610:  ANDWF  3E,F
....................       for (DOC = GLCD.y1; DOC<=GLCD.y2; DOC++) 
0612:  MOVFF  3D,449
0616:  MOVLB  4
0618:  MOVF   x49,W
061A:  SUBWF  3F,W
061C:  BTFSS  FD8.0
061E:  BRA    0710
....................       { 
....................          if(DOC>31)   {hesox = 8+GLCD.x1;hesox2= GLCD.x2+8; hesoy = DOC-32;}
0620:  MOVF   x49,W
0622:  SUBLW  1F
0624:  BC    063A
0626:  MOVLW  08
0628:  ADDWF  3C,W
062A:  MOVWF  x46
062C:  MOVLW  08
062E:  ADDWF  3E,W
0630:  MOVWF  x47
0632:  MOVLW  20
0634:  SUBWF  x49,W
0636:  MOVWF  x48
0638:  BRA    0646
....................          else         {hesox = GLCD.x1  ;hesox2 = GLCD.x2 ; hesoy = DOC;   }
063A:  MOVFF  3C,446
063E:  MOVFF  3E,447
0642:  MOVFF  449,448
....................          GLCD_COMMAND( 0x80 |hesoy);   
0646:  MOVF   x48,W
0648:  IORLW  80
064A:  MOVWF  x4B
064C:  MOVWF  x4C
064E:  MOVLB  0
0650:  RCALL  04C4
....................          GLCD_COMMAND( 0x80 |hesox);  
0652:  MOVLB  4
0654:  MOVF   x46,W
0656:  IORLW  80
0658:  MOVWF  x4B
065A:  MOVWF  x4C
065C:  MOVLB  0
065E:  RCALL  04C4
....................       
....................          for (NGANG=hesox; NGANG <=hesox2; NGANG++) 
0660:  MOVFF  446,44A
0664:  MOVLB  4
0666:  MOVF   x4A,W
0668:  SUBWF  x47,W
066A:  BNC   070C
....................          { 
....................             GLCD_DATA( GLCD.PIXEL[hesoy][NGANG].nbyte[1]);   // Write High Byte. 
066C:  CLRF   x76
066E:  MOVFF  448,475
0672:  CLRF   x78
0674:  MOVLW  20
0676:  MOVWF  x77
0678:  MOVLB  0
067A:  RCALL  0592
067C:  MOVF   01,W
067E:  ADDLW  08
0680:  MOVLB  4
0682:  MOVWF  x4B
0684:  MOVLW  00
0686:  ADDWFC 02,W
0688:  MOVWF  x4C
068A:  CLRF   03
068C:  MOVFF  44A,02
0690:  BCF    FD8.0
0692:  RLCF   02,F
0694:  RLCF   03,F
0696:  MOVF   02,W
0698:  ADDWF  x4B,F
069A:  MOVF   03,W
069C:  ADDWFC x4C,F
069E:  MOVLW  01
06A0:  ADDWF  x4B,W
06A2:  MOVWF  01
06A4:  MOVLW  00
06A6:  ADDWFC x4C,W
06A8:  MOVWF  03
06AA:  MOVF   01,W
06AC:  ADDLW  38
06AE:  MOVWF  FE9
06B0:  MOVLW  00
06B2:  ADDWFC 03,W
06B4:  MOVWF  FEA
06B6:  MOVFF  FEF,44E
06BA:  MOVLB  0
06BC:  RCALL  05B4
....................             GLCD_DATA( GLCD.PIXEL[hesoy][NGANG].nbyte[0]);   // Write Low Byte. 
06BE:  MOVLB  4
06C0:  CLRF   x76
06C2:  MOVFF  448,475
06C6:  CLRF   x78
06C8:  MOVLW  20
06CA:  MOVWF  x77
06CC:  MOVLB  0
06CE:  RCALL  0592
06D0:  MOVF   01,W
06D2:  ADDLW  08
06D4:  MOVLB  4
06D6:  MOVWF  x4B
06D8:  MOVLW  00
06DA:  ADDWFC 02,W
06DC:  MOVWF  x4C
06DE:  CLRF   03
06E0:  MOVFF  44A,02
06E4:  BCF    FD8.0
06E6:  RLCF   02,F
06E8:  RLCF   03,F
06EA:  MOVF   02,W
06EC:  ADDWF  x4B,F
06EE:  MOVF   03,W
06F0:  ADDWFC x4C,F
06F2:  MOVLW  38
06F4:  ADDWF  x4B,W
06F6:  MOVWF  FE9
06F8:  MOVLW  00
06FA:  ADDWFC x4C,W
06FC:  MOVWF  FEA
06FE:  MOVFF  FEF,44E
0702:  MOVLB  0
0704:  RCALL  05B4
0706:  MOVLB  4
0708:  INCF   x4A,F
070A:  BRA    0666
....................          } 
070C:  INCF   x49,F
070E:  BRA    0618
....................        } 
....................     GLCD.tt_update = FALSE; 
0710:  BCF    3B.2
0712:  MOVLB  0
....................   }  
....................   return OK;
0714:  MOVLW  00
0716:  MOVWF  01
0718:  RETURN 0
.................... }
.................... 
.................... result GLCD_VERTICAL_LINE(unsigned int8 x, unsigned int8 y1,unsigned int8 y2, int1 color)
.................... {
....................    unsigned int8 i;
....................    for(i=y1;i<=y2;i++) glcd_pixel_temp(x, i, color) ;
*
0E54:  MOVFF  46A,46D
0E58:  MOVLB  4
0E5A:  MOVF   x6D,W
0E5C:  SUBWF  x6B,W
0E5E:  BNC   0E76
0E60:  MOVFF  469,46E
0E64:  MOVFF  46D,46F
0E68:  MOVFF  46C,470
0E6C:  MOVLB  0
0E6E:  BRA    0D4A
0E70:  MOVLB  4
0E72:  INCF   x6D,F
0E74:  BRA    0E5A
....................    return OK;
0E76:  MOVLW  00
0E78:  MOVWF  01
0E7A:  MOVLB  0
0E7C:  RETURN 0
.................... }
.................... 
.................... result GLCD_HORIZONE_LINE(unsigned int8 x1, unsigned int8 x2,unsigned int8 y, int1 color)
.................... {
....................   int8 doc;
....................   unsigned int8 i,right,left;
....................   if(y>31){x1 += 128;x2 += 128; y-= 32;}; 
*
0762:  MOVLB  4
0764:  MOVF   x6B,W
0766:  SUBLW  1F
0768:  BC    0774
076A:  MOVLW  80
076C:  ADDWF  x69,F
076E:  ADDWF  x6A,F
0770:  MOVLW  20
0772:  SUBWF  x6B,F
....................   left=x1/16; right = x2/16;DOC = y; 
0774:  SWAPF  x69,W
0776:  MOVWF  x70
0778:  MOVLW  0F
077A:  ANDWF  x70,F
077C:  SWAPF  x6A,W
077E:  MOVWF  x6F
0780:  MOVLW  0F
0782:  ANDWF  x6F,F
0784:  MOVFF  46B,46D
....................    if (left==right) 
0788:  MOVF   x6F,W
078A:  SUBWF  x70,W
078C:  BTFSS  FD8.2
078E:  BRA    097A
....................    {
....................           if(color)
0790:  MOVF   x6C,F
0792:  BTFSC  FD8.2
0794:  BRA    0886
....................                GLCD.PIXEL[DOC][left].word= GLCD.PIXEL[DOC][left].word | (0xffff<<(15-(x2%16))) & (0xffff>>(x1%16));           
0796:  CLRF   x76
0798:  MOVFF  46D,475
079C:  CLRF   x78
079E:  MOVLW  20
07A0:  MOVWF  x77
07A2:  MOVLB  0
07A4:  RCALL  0592
07A6:  MOVF   01,W
07A8:  ADDLW  08
07AA:  MOVLB  4
07AC:  MOVWF  x71
07AE:  MOVLW  00
07B0:  ADDWFC 02,W
07B2:  MOVWF  x72
07B4:  CLRF   03
07B6:  MOVFF  470,02
07BA:  BCF    FD8.0
07BC:  RLCF   02,F
07BE:  RLCF   03,F
07C0:  MOVF   02,W
07C2:  ADDWF  x71,F
07C4:  MOVF   03,W
07C6:  ADDWFC x72,F
07C8:  MOVLW  38
07CA:  ADDWF  x71,W
07CC:  MOVWF  01
07CE:  MOVLW  00
07D0:  ADDWFC x72,W
07D2:  MOVWF  03
07D4:  MOVFF  01,473
07D8:  MOVWF  x74
07DA:  CLRF   x76
07DC:  MOVFF  46D,475
07E0:  CLRF   x78
07E2:  MOVLW  20
07E4:  MOVWF  x77
07E6:  MOVLB  0
07E8:  RCALL  0592
07EA:  MOVF   01,W
07EC:  ADDLW  08
07EE:  MOVLB  4
07F0:  MOVWF  x75
07F2:  MOVLW  00
07F4:  ADDWFC 02,W
07F6:  MOVWF  x76
07F8:  CLRF   03
07FA:  MOVFF  470,02
07FE:  BCF    FD8.0
0800:  RLCF   02,F
0802:  RLCF   03,F
0804:  MOVF   02,W
0806:  ADDWF  x75,F
0808:  MOVF   03,W
080A:  ADDWFC x76,F
080C:  MOVLW  38
080E:  ADDWF  x75,W
0810:  MOVWF  FE9
0812:  MOVLW  00
0814:  ADDWFC x76,W
0816:  MOVWF  FEA
0818:  MOVFF  FEC,478
081C:  MOVF   FED,F
081E:  MOVFF  FEF,477
0822:  MOVF   x6A,W
0824:  ANDLW  0F
0826:  XORLW  FF
0828:  ADDLW  10
082A:  MOVWF  00
082C:  SETF   x7A
082E:  SETF   x79
0830:  MOVF   00,F
0832:  BZ    083E
0834:  BCF    FD8.0
0836:  RLCF   x79,F
0838:  RLCF   x7A,F
083A:  DECFSZ 00,F
083C:  BRA    0834
083E:  MOVF   x69,W
0840:  ANDLW  0F
0842:  MOVWF  00
0844:  SETF   03
0846:  SETF   02
0848:  MOVF   00,F
084A:  BZ    0856
084C:  BCF    FD8.0
084E:  RRCF   03,F
0850:  RRCF   02,F
0852:  DECFSZ 00,F
0854:  BRA    084C
0856:  MOVF   02,W
0858:  ANDWF  x79,W
085A:  MOVWF  00
085C:  MOVF   03,W
085E:  ANDWF  x7A,W
0860:  MOVWF  03
0862:  MOVF   00,W
0864:  IORWF  x77,W
0866:  MOVWF  00
0868:  MOVF   03,W
086A:  IORWF  x78,W
086C:  MOVWF  03
086E:  MOVFF  00,477
0872:  MOVWF  x78
0874:  MOVFF  474,FEA
0878:  MOVFF  473,FE9
087C:  MOVWF  FEC
087E:  MOVF   FED,F
0880:  MOVFF  00,FEF
0884:  BRA    0978
....................           else 
....................                GLCD.PIXEL[DOC][left].word= GLCD.PIXEL[DOC][left].word & (~((0xffff<<(15-(x2%16))) & (0xffff>>(x1%16))));   
0886:  CLRF   x76
0888:  MOVFF  46D,475
088C:  CLRF   x78
088E:  MOVLW  20
0890:  MOVWF  x77
0892:  MOVLB  0
0894:  RCALL  0592
0896:  MOVF   01,W
0898:  ADDLW  08
089A:  MOVLB  4
089C:  MOVWF  x71
089E:  MOVLW  00
08A0:  ADDWFC 02,W
08A2:  MOVWF  x72
08A4:  CLRF   03
08A6:  MOVFF  470,02
08AA:  BCF    FD8.0
08AC:  RLCF   02,F
08AE:  RLCF   03,F
08B0:  MOVF   02,W
08B2:  ADDWF  x71,F
08B4:  MOVF   03,W
08B6:  ADDWFC x72,F
08B8:  MOVLW  38
08BA:  ADDWF  x71,W
08BC:  MOVWF  01
08BE:  MOVLW  00
08C0:  ADDWFC x72,W
08C2:  MOVWF  03
08C4:  MOVFF  01,473
08C8:  MOVWF  x74
08CA:  CLRF   x76
08CC:  MOVFF  46D,475
08D0:  CLRF   x78
08D2:  MOVLW  20
08D4:  MOVWF  x77
08D6:  MOVLB  0
08D8:  RCALL  0592
08DA:  MOVF   01,W
08DC:  ADDLW  08
08DE:  MOVLB  4
08E0:  MOVWF  x75
08E2:  MOVLW  00
08E4:  ADDWFC 02,W
08E6:  MOVWF  x76
08E8:  CLRF   03
08EA:  MOVFF  470,02
08EE:  BCF    FD8.0
08F0:  RLCF   02,F
08F2:  RLCF   03,F
08F4:  MOVF   02,W
08F6:  ADDWF  x75,F
08F8:  MOVF   03,W
08FA:  ADDWFC x76,F
08FC:  MOVLW  38
08FE:  ADDWF  x75,W
0900:  MOVWF  FE9
0902:  MOVLW  00
0904:  ADDWFC x76,W
0906:  MOVWF  FEA
0908:  MOVFF  FEC,478
090C:  MOVF   FED,F
090E:  MOVFF  FEF,477
0912:  MOVF   x6A,W
0914:  ANDLW  0F
0916:  XORLW  FF
0918:  ADDLW  10
091A:  MOVWF  00
091C:  SETF   x7A
091E:  SETF   x79
0920:  MOVF   00,F
0922:  BZ    092E
0924:  BCF    FD8.0
0926:  RLCF   x79,F
0928:  RLCF   x7A,F
092A:  DECFSZ 00,F
092C:  BRA    0924
092E:  MOVF   x69,W
0930:  ANDLW  0F
0932:  MOVWF  00
0934:  SETF   03
0936:  SETF   02
0938:  MOVF   00,F
093A:  BZ    0946
093C:  BCF    FD8.0
093E:  RRCF   03,F
0940:  RRCF   02,F
0942:  DECFSZ 00,F
0944:  BRA    093C
0946:  MOVF   02,W
0948:  ANDWF  x79,W
094A:  MOVWF  00
094C:  MOVF   03,W
094E:  ANDWF  x7A,W
0950:  MOVWF  03
0952:  MOVF   00,W
0954:  CLRF   00
0956:  DECF   00,F
0958:  XORWF  00,F
095A:  MOVLW  FF
095C:  XORWF  03,F
095E:  MOVF   00,W
0960:  ANDWF  x77,W
0962:  MOVWF  00
0964:  MOVF   03,W
0966:  ANDWF  x78,W
0968:  MOVFF  474,FEA
096C:  MOVFF  473,FE9
0970:  MOVWF  FEC
0972:  MOVF   FED,F
0974:  MOVFF  00,FEF
....................    }
0978:  BRA    0D42
....................    else 
....................    {
....................           if(color)
097A:  MOVF   x6C,F
097C:  BTFSC  FD8.2
097E:  BRA    0B56
....................           {    GLCD.PIXEL[DOC][right].word = GLCD.PIXEL[DOC][right].word | (0xffff<<(15-(x2%16)));
0980:  CLRF   x76
0982:  MOVFF  46D,475
0986:  CLRF   x78
0988:  MOVLW  20
098A:  MOVWF  x77
098C:  MOVLB  0
098E:  RCALL  0592
0990:  MOVF   01,W
0992:  ADDLW  08
0994:  MOVLB  4
0996:  MOVWF  x71
0998:  MOVLW  00
099A:  ADDWFC 02,W
099C:  MOVWF  x72
099E:  CLRF   03
09A0:  MOVFF  46F,02
09A4:  BCF    FD8.0
09A6:  RLCF   02,F
09A8:  RLCF   03,F
09AA:  MOVF   02,W
09AC:  ADDWF  x71,F
09AE:  MOVF   03,W
09B0:  ADDWFC x72,F
09B2:  MOVLW  38
09B4:  ADDWF  x71,W
09B6:  MOVWF  01
09B8:  MOVLW  00
09BA:  ADDWFC x72,W
09BC:  MOVWF  03
09BE:  MOVFF  01,473
09C2:  MOVWF  x74
09C4:  CLRF   x76
09C6:  MOVFF  46D,475
09CA:  CLRF   x78
09CC:  MOVLW  20
09CE:  MOVWF  x77
09D0:  MOVLB  0
09D2:  RCALL  0592
09D4:  MOVF   01,W
09D6:  ADDLW  08
09D8:  MOVLB  4
09DA:  MOVWF  x75
09DC:  MOVLW  00
09DE:  ADDWFC 02,W
09E0:  MOVWF  x76
09E2:  CLRF   03
09E4:  MOVFF  46F,02
09E8:  BCF    FD8.0
09EA:  RLCF   02,F
09EC:  RLCF   03,F
09EE:  MOVF   02,W
09F0:  ADDWF  x75,F
09F2:  MOVF   03,W
09F4:  ADDWFC x76,F
09F6:  MOVLW  38
09F8:  ADDWF  x75,W
09FA:  MOVWF  FE9
09FC:  MOVLW  00
09FE:  ADDWFC x76,W
0A00:  MOVWF  FEA
0A02:  MOVFF  FEC,478
0A06:  MOVF   FED,F
0A08:  MOVFF  FEF,477
0A0C:  MOVF   x6A,W
0A0E:  ANDLW  0F
0A10:  XORLW  FF
0A12:  ADDLW  10
0A14:  MOVWF  00
0A16:  SETF   03
0A18:  SETF   02
0A1A:  MOVF   00,F
0A1C:  BZ    0A28
0A1E:  BCF    FD8.0
0A20:  RLCF   02,F
0A22:  RLCF   03,F
0A24:  DECFSZ 00,F
0A26:  BRA    0A1E
0A28:  MOVF   02,W
0A2A:  IORWF  x77,W
0A2C:  MOVWF  00
0A2E:  MOVF   03,W
0A30:  IORWF  x78,W
0A32:  MOVFF  474,FEA
0A36:  MOVFF  473,FE9
0A3A:  MOVWF  FEC
0A3C:  MOVF   FED,F
0A3E:  MOVFF  00,FEF
....................                GLCD.PIXEL[DOC][left].word = GLCD.PIXEL[DOC][left].word|(0xffff>>(x1%16));
0A42:  CLRF   x76
0A44:  MOVFF  46D,475
0A48:  CLRF   x78
0A4A:  MOVLW  20
0A4C:  MOVWF  x77
0A4E:  MOVLB  0
0A50:  RCALL  0592
0A52:  MOVF   01,W
0A54:  ADDLW  08
0A56:  MOVLB  4
0A58:  MOVWF  x71
0A5A:  MOVLW  00
0A5C:  ADDWFC 02,W
0A5E:  MOVWF  x72
0A60:  CLRF   03
0A62:  MOVFF  470,02
0A66:  BCF    FD8.0
0A68:  RLCF   02,F
0A6A:  RLCF   03,F
0A6C:  MOVF   02,W
0A6E:  ADDWF  x71,F
0A70:  MOVF   03,W
0A72:  ADDWFC x72,F
0A74:  MOVLW  38
0A76:  ADDWF  x71,W
0A78:  MOVWF  01
0A7A:  MOVLW  00
0A7C:  ADDWFC x72,W
0A7E:  MOVWF  03
0A80:  MOVFF  01,473
0A84:  MOVWF  x74
0A86:  CLRF   x76
0A88:  MOVFF  46D,475
0A8C:  CLRF   x78
0A8E:  MOVLW  20
0A90:  MOVWF  x77
0A92:  MOVLB  0
0A94:  RCALL  0592
0A96:  MOVF   01,W
0A98:  ADDLW  08
0A9A:  MOVLB  4
0A9C:  MOVWF  x75
0A9E:  MOVLW  00
0AA0:  ADDWFC 02,W
0AA2:  MOVWF  x76
0AA4:  CLRF   03
0AA6:  MOVFF  470,02
0AAA:  BCF    FD8.0
0AAC:  RLCF   02,F
0AAE:  RLCF   03,F
0AB0:  MOVF   02,W
0AB2:  ADDWF  x75,F
0AB4:  MOVF   03,W
0AB6:  ADDWFC x76,F
0AB8:  MOVLW  38
0ABA:  ADDWF  x75,W
0ABC:  MOVWF  FE9
0ABE:  MOVLW  00
0AC0:  ADDWFC x76,W
0AC2:  MOVWF  FEA
0AC4:  MOVFF  FEC,478
0AC8:  MOVF   FED,F
0ACA:  MOVFF  FEF,477
0ACE:  MOVF   x69,W
0AD0:  ANDLW  0F
0AD2:  MOVWF  00
0AD4:  SETF   03
0AD6:  SETF   02
0AD8:  MOVF   00,F
0ADA:  BZ    0AE6
0ADC:  BCF    FD8.0
0ADE:  RRCF   03,F
0AE0:  RRCF   02,F
0AE2:  DECFSZ 00,F
0AE4:  BRA    0ADC
0AE6:  MOVF   02,W
0AE8:  IORWF  x77,W
0AEA:  MOVWF  00
0AEC:  MOVF   03,W
0AEE:  IORWF  x78,W
0AF0:  MOVFF  474,FEA
0AF4:  MOVFF  473,FE9
0AF8:  MOVWF  FEC
0AFA:  MOVF   FED,F
0AFC:  MOVFF  00,FEF
....................                for(i = left + 1; i < right; i++) GLCD.PIXEL[DOC][i].word=0xffff;
0B00:  MOVLW  01
0B02:  ADDWF  x70,W
0B04:  MOVWF  x6E
0B06:  MOVF   x6F,W
0B08:  SUBWF  x6E,W
0B0A:  BC    0B54
0B0C:  CLRF   x76
0B0E:  MOVFF  46D,475
0B12:  CLRF   x78
0B14:  MOVLW  20
0B16:  MOVWF  x77
0B18:  MOVLB  0
0B1A:  RCALL  0592
0B1C:  MOVF   01,W
0B1E:  ADDLW  08
0B20:  MOVLB  4
0B22:  MOVWF  x71
0B24:  MOVLW  00
0B26:  ADDWFC 02,W
0B28:  MOVWF  x72
0B2A:  CLRF   03
0B2C:  MOVFF  46E,02
0B30:  BCF    FD8.0
0B32:  RLCF   02,F
0B34:  RLCF   03,F
0B36:  MOVF   02,W
0B38:  ADDWF  x71,F
0B3A:  MOVF   03,W
0B3C:  ADDWFC x72,F
0B3E:  MOVLW  38
0B40:  ADDWF  x71,W
0B42:  MOVWF  FE9
0B44:  MOVLW  00
0B46:  ADDWFC x72,W
0B48:  MOVWF  FEA
0B4A:  SETF   FEC
0B4C:  MOVF   FED,F
0B4E:  SETF   FEF
0B50:  INCF   x6E,F
0B52:  BRA    0B06
....................           }
0B54:  BRA    0D42
....................           else 
....................           {    
....................                GLCD.PIXEL[DOC][right].word = GLCD.PIXEL[DOC][right].word & (~(0xffff<<(15-(x2%16))));
0B56:  CLRF   x76
0B58:  MOVFF  46D,475
0B5C:  CLRF   x78
0B5E:  MOVLW  20
0B60:  MOVWF  x77
0B62:  MOVLB  0
0B64:  RCALL  0592
0B66:  MOVF   01,W
0B68:  ADDLW  08
0B6A:  MOVLB  4
0B6C:  MOVWF  x71
0B6E:  MOVLW  00
0B70:  ADDWFC 02,W
0B72:  MOVWF  x72
0B74:  CLRF   03
0B76:  MOVFF  46F,02
0B7A:  BCF    FD8.0
0B7C:  RLCF   02,F
0B7E:  RLCF   03,F
0B80:  MOVF   02,W
0B82:  ADDWF  x71,F
0B84:  MOVF   03,W
0B86:  ADDWFC x72,F
0B88:  MOVLW  38
0B8A:  ADDWF  x71,W
0B8C:  MOVWF  01
0B8E:  MOVLW  00
0B90:  ADDWFC x72,W
0B92:  MOVWF  03
0B94:  MOVFF  01,473
0B98:  MOVWF  x74
0B9A:  CLRF   x76
0B9C:  MOVFF  46D,475
0BA0:  CLRF   x78
0BA2:  MOVLW  20
0BA4:  MOVWF  x77
0BA6:  MOVLB  0
0BA8:  RCALL  0592
0BAA:  MOVF   01,W
0BAC:  ADDLW  08
0BAE:  MOVLB  4
0BB0:  MOVWF  x75
0BB2:  MOVLW  00
0BB4:  ADDWFC 02,W
0BB6:  MOVWF  x76
0BB8:  CLRF   03
0BBA:  MOVFF  46F,02
0BBE:  BCF    FD8.0
0BC0:  RLCF   02,F
0BC2:  RLCF   03,F
0BC4:  MOVF   02,W
0BC6:  ADDWF  x75,F
0BC8:  MOVF   03,W
0BCA:  ADDWFC x76,F
0BCC:  MOVLW  38
0BCE:  ADDWF  x75,W
0BD0:  MOVWF  FE9
0BD2:  MOVLW  00
0BD4:  ADDWFC x76,W
0BD6:  MOVWF  FEA
0BD8:  MOVFF  FEC,478
0BDC:  MOVF   FED,F
0BDE:  MOVFF  FEF,477
0BE2:  MOVF   x6A,W
0BE4:  ANDLW  0F
0BE6:  XORLW  FF
0BE8:  ADDLW  10
0BEA:  MOVWF  00
0BEC:  SETF   03
0BEE:  SETF   02
0BF0:  MOVF   00,F
0BF2:  BZ    0BFE
0BF4:  BCF    FD8.0
0BF6:  RLCF   02,F
0BF8:  RLCF   03,F
0BFA:  DECFSZ 00,F
0BFC:  BRA    0BF4
0BFE:  MOVF   02,W
0C00:  CLRF   00
0C02:  DECF   00,F
0C04:  XORWF  00,F
0C06:  MOVLW  FF
0C08:  XORWF  03,F
0C0A:  MOVF   00,W
0C0C:  ANDWF  x77,W
0C0E:  MOVWF  00
0C10:  MOVF   03,W
0C12:  ANDWF  x78,W
0C14:  MOVFF  474,FEA
0C18:  MOVFF  473,FE9
0C1C:  MOVWF  FEC
0C1E:  MOVF   FED,F
0C20:  MOVFF  00,FEF
....................                GLCD.PIXEL[DOC][left].word = GLCD.PIXEL[DOC][left].word& (~(0xffff>>(x1%16)));
0C24:  CLRF   x76
0C26:  MOVFF  46D,475
0C2A:  CLRF   x78
0C2C:  MOVLW  20
0C2E:  MOVWF  x77
0C30:  MOVLB  0
0C32:  RCALL  0592
0C34:  MOVF   01,W
0C36:  ADDLW  08
0C38:  MOVLB  4
0C3A:  MOVWF  x71
0C3C:  MOVLW  00
0C3E:  ADDWFC 02,W
0C40:  MOVWF  x72
0C42:  CLRF   03
0C44:  MOVFF  470,02
0C48:  BCF    FD8.0
0C4A:  RLCF   02,F
0C4C:  RLCF   03,F
0C4E:  MOVF   02,W
0C50:  ADDWF  x71,F
0C52:  MOVF   03,W
0C54:  ADDWFC x72,F
0C56:  MOVLW  38
0C58:  ADDWF  x71,W
0C5A:  MOVWF  01
0C5C:  MOVLW  00
0C5E:  ADDWFC x72,W
0C60:  MOVWF  03
0C62:  MOVFF  01,473
0C66:  MOVWF  x74
0C68:  CLRF   x76
0C6A:  MOVFF  46D,475
0C6E:  CLRF   x78
0C70:  MOVLW  20
0C72:  MOVWF  x77
0C74:  MOVLB  0
0C76:  RCALL  0592
0C78:  MOVF   01,W
0C7A:  ADDLW  08
0C7C:  MOVLB  4
0C7E:  MOVWF  x75
0C80:  MOVLW  00
0C82:  ADDWFC 02,W
0C84:  MOVWF  x76
0C86:  CLRF   03
0C88:  MOVFF  470,02
0C8C:  BCF    FD8.0
0C8E:  RLCF   02,F
0C90:  RLCF   03,F
0C92:  MOVF   02,W
0C94:  ADDWF  x75,F
0C96:  MOVF   03,W
0C98:  ADDWFC x76,F
0C9A:  MOVLW  38
0C9C:  ADDWF  x75,W
0C9E:  MOVWF  FE9
0CA0:  MOVLW  00
0CA2:  ADDWFC x76,W
0CA4:  MOVWF  FEA
0CA6:  MOVFF  FEC,478
0CAA:  MOVF   FED,F
0CAC:  MOVFF  FEF,477
0CB0:  MOVF   x69,W
0CB2:  ANDLW  0F
0CB4:  MOVWF  00
0CB6:  SETF   03
0CB8:  SETF   02
0CBA:  MOVF   00,F
0CBC:  BZ    0CC8
0CBE:  BCF    FD8.0
0CC0:  RRCF   03,F
0CC2:  RRCF   02,F
0CC4:  DECFSZ 00,F
0CC6:  BRA    0CBE
0CC8:  MOVF   02,W
0CCA:  CLRF   00
0CCC:  DECF   00,F
0CCE:  XORWF  00,F
0CD0:  MOVLW  FF
0CD2:  XORWF  03,F
0CD4:  MOVF   00,W
0CD6:  ANDWF  x77,W
0CD8:  MOVWF  00
0CDA:  MOVF   03,W
0CDC:  ANDWF  x78,W
0CDE:  MOVFF  474,FEA
0CE2:  MOVFF  473,FE9
0CE6:  MOVWF  FEC
0CE8:  MOVF   FED,F
0CEA:  MOVFF  00,FEF
....................                for(i = left + 1; i < right; i++) GLCD.PIXEL[DOC][i].word=0;
0CEE:  MOVLW  01
0CF0:  ADDWF  x70,W
0CF2:  MOVWF  x6E
0CF4:  MOVF   x6F,W
0CF6:  SUBWF  x6E,W
0CF8:  BC    0D42
0CFA:  CLRF   x76
0CFC:  MOVFF  46D,475
0D00:  CLRF   x78
0D02:  MOVLW  20
0D04:  MOVWF  x77
0D06:  MOVLB  0
0D08:  RCALL  0592
0D0A:  MOVF   01,W
0D0C:  ADDLW  08
0D0E:  MOVLB  4
0D10:  MOVWF  x71
0D12:  MOVLW  00
0D14:  ADDWFC 02,W
0D16:  MOVWF  x72
0D18:  CLRF   03
0D1A:  MOVFF  46E,02
0D1E:  BCF    FD8.0
0D20:  RLCF   02,F
0D22:  RLCF   03,F
0D24:  MOVF   02,W
0D26:  ADDWF  x71,F
0D28:  MOVF   03,W
0D2A:  ADDWFC x72,F
0D2C:  MOVLW  38
0D2E:  ADDWF  x71,W
0D30:  MOVWF  FE9
0D32:  MOVLW  00
0D34:  ADDWFC x72,W
0D36:  MOVWF  FEA
0D38:  CLRF   FEC
0D3A:  MOVF   FED,F
0D3C:  CLRF   FEF
0D3E:  INCF   x6E,F
0D40:  BRA    0CF4
....................           } 
....................    }
....................    return OK;
0D42:  MOVLW  00
0D44:  MOVWF  01
0D46:  MOVLB  0
0D48:  RETURN 0
.................... }
.................... 
.................... result glcd_text_setup(unsigned int16 x, unsigned int16 y,int8 size, int8 color,int1 overlay)
.................... {
....................       GLCD.mau = color;
*
0F88:  BCF    3B.0
0F8A:  MOVLB  4
0F8C:  BTFSC  x4B.0
0F8E:  BSF    3B.0
....................       GLCD.size = size;
0F90:  MOVFF  44A,3A
....................       GLCD.x    = x;
0F94:  MOVFF  446,38
....................       GLCD.y    =y;
0F98:  MOVFF  448,39
....................       GLCD.tt_text=0;
0F9C:  BCF    3B.1
....................       GLCD.overlay=overlay;
0F9E:  BCF    3B.3
0FA0:  BTFSC  x4C.0
0FA2:  BSF    3B.3
....................       return OK;
0FA4:  MOVLW  00
0FA6:  MOVWF  01
0FA8:  MOVLB  0
0FAA:  RETURN 0
.................... }
.................... 
.................... result glcd_text( char t)
.................... {
....................       static unsigned int8 x1,x2,y1,y2;
....................       unsigned int8 j, k, l, m;                      
....................       unsigned int8 pixelData[5];
....................       if(GLCD.overlay)
0FAC:  BTFSS  3B.3
0FAE:  BRA    0FEA
....................       {
....................             glcd_rect(GLCD.x,GLCD.y,GLCD.x+6*GLCD.size,GLCD.y+7*GLCD.size,1,!GLCD.mau);
0FB0:  MOVF   3A,W
0FB2:  MULLW  06
0FB4:  MOVF   FF3,W
0FB6:  ADDWF  38,W
0FB8:  MOVLB  4
0FBA:  MOVWF  x5B
0FBC:  MOVF   3A,W
0FBE:  MULLW  07
0FC0:  MOVF   FF3,W
0FC2:  ADDWF  39,W
0FC4:  MOVWF  x5C
0FC6:  MOVLW  00
0FC8:  BTFSS  3B.0
0FCA:  MOVLW  01
0FCC:  MOVWF  x5D
0FCE:  MOVFF  38,45E
0FD2:  MOVFF  39,45F
0FD6:  MOVFF  45B,460
0FDA:  MOVFF  45C,461
0FDE:  MOVLW  01
0FE0:  MOVWF  x62
0FE2:  MOVFF  45D,463
0FE6:  MOVLB  0
0FE8:  RCALL  0EC8
....................       }
....................       if(GLCD.tt_text==0)
0FEA:  BTFSC  3B.1
0FEC:  BRA    0FF8
....................       {
....................           x1=GLCD.x;
0FEE:  MOVFF  38,440
....................           y1=GLCD.y;
0FF2:  MOVFF  39,442
....................           GLCD.tt_text=1;
0FF6:  BSF    3B.1
....................       }
....................       if(t < 'S')
0FF8:  MOVLB  4
0FFA:  MOVF   x51,W
0FFC:  SUBLW  52
0FFE:  BNC   1038
....................          memcpy(pixelData, GLCD_FONT[t - ' '], 5);
1000:  MOVLW  20
1002:  SUBWF  x51,W
1004:  MULLW  05
1006:  MOVF   FF3,W
1008:  CLRF   03
100A:  MOVWF  x5B
100C:  MOVLW  04
100E:  MOVWF  FEA
1010:  MOVLW  56
1012:  MOVWF  FE9
1014:  CLRF   x5F
1016:  MOVFF  45B,45E
101A:  MOVLW  05
101C:  MOVWF  01
101E:  CLRF   FF7
1020:  MOVF   x5B,W
1022:  MOVLB  0
1024:  CALL   0004
1028:  TBLRD*-
102A:  TBLRD*+
102C:  MOVFF  FF5,FEE
1030:  DECFSZ 01,F
1032:  BRA    102A
1034:  BRA    1082
1036:  MOVLB  4
....................       else if(t <= '~') 
1038:  MOVF   x51,W
103A:  SUBLW  7E
103C:  BNC   1076
....................          memcpy(pixelData, GLCD_FONT2[t - 'S'], 5);
103E:  MOVLW  53
1040:  SUBWF  x51,W
1042:  MULLW  05
1044:  MOVF   FF3,W
1046:  CLRF   03
1048:  MOVWF  x5B
104A:  MOVLW  04
104C:  MOVWF  FEA
104E:  MOVLW  56
1050:  MOVWF  FE9
1052:  CLRF   x5F
1054:  MOVFF  45B,45E
1058:  MOVLW  05
105A:  MOVWF  01
105C:  CLRF   FF7
105E:  MOVF   x5B,W
1060:  MOVLB  0
1062:  CALL   0114
1066:  TBLRD*-
1068:  TBLRD*+
106A:  MOVFF  FF5,FEE
106E:  DECFSZ 01,F
1070:  BRA    1068
1072:  BRA    1082
1074:  MOVLB  4
....................       else
....................          memcpy(pixelData, GLCD_FONT[0], 5);   
1076:  CLRF   x56
1078:  CLRF   x57
107A:  CLRF   x58
107C:  CLRF   x59
107E:  CLRF   x5A
1080:  MOVLB  0
....................       if(GLCD.x+5*GLCD.size >= GLCD_WIDTH)         
1082:  MOVF   3A,W
1084:  MULLW  05
1086:  MOVF   FF3,W
1088:  ADDWF  38,W
108A:  SUBLW  7F
108C:  BC    109A
....................       {
....................          GLCD.x = 0;                           
108E:  CLRF   38
....................          GLCD.y += 7*GLCD.size + 1;                 
1090:  MOVF   3A,W
1092:  MULLW  07
1094:  MOVF   FF3,W
1096:  ADDLW  01
1098:  ADDWF  39,F
....................       }
....................       for(j=0; j<5; ++j, GLCD.x+=GLCD.size)         
109A:  MOVLB  4
109C:  CLRF   x52
109E:  MOVF   x52,W
10A0:  SUBLW  04
10A2:  BNC   111A
....................       {
....................          for(k=0; k < 7; ++k)             
10A4:  CLRF   x53
10A6:  MOVF   x53,W
10A8:  SUBLW  06
10AA:  BNC   1112
....................          {
....................             if(bit_test(pixelData[j], k)) 
10AC:  CLRF   03
10AE:  MOVF   x52,W
10B0:  ADDLW  56
10B2:  MOVWF  FE9
10B4:  MOVLW  04
10B6:  ADDWFC 03,W
10B8:  MOVWF  FEA
10BA:  MOVFF  FEF,00
10BE:  MOVF   x53,W
10C0:  MOVWF  01
10C2:  BZ    10CC
10C4:  BCF    FD8.0
10C6:  RRCF   00,F
10C8:  DECFSZ 01,F
10CA:  BRA    10C4
10CC:  BTFSS  00.0
10CE:  BRA    110E
....................             {
....................                for(l=0; l < GLCD.size; ++l)       
10D0:  CLRF   x54
10D2:  MOVF   3A,W
10D4:  SUBWF  x54,W
10D6:  BC    110E
....................                     GLCD_horizone_line(GLCD.x, GLCD.x+GLCD.size-1,GLCD.y+k*GLCD.size+l,GLCD.mau);   
10D8:  MOVF   3A,W
10DA:  ADDWF  38,W
10DC:  ADDLW  FF
10DE:  MOVWF  x5B
10E0:  MOVF   x53,W
10E2:  MULWF  3A
10E4:  MOVF   FF3,W
10E6:  ADDWF  39,W
10E8:  ADDWF  x54,W
10EA:  MOVWF  x5C
10EC:  MOVLW  00
10EE:  BTFSC  3B.0
10F0:  MOVLW  01
10F2:  MOVWF  x5D
10F4:  MOVFF  38,469
10F8:  MOVFF  45B,46A
10FC:  MOVFF  45C,46B
1100:  MOVWF  x6C
1102:  MOVLB  0
1104:  CALL   0762
1108:  MOVLB  4
110A:  INCF   x54,F
110C:  BRA    10D2
....................             }
110E:  INCF   x53,F
1110:  BRA    10A6
....................          }
1112:  INCF   x52,F
1114:  MOVF   3A,W
1116:  ADDWF  38,F
1118:  BRA    109E
....................       }
....................       x2 = GLCD.x;
111A:  MOVFF  38,441
....................       GLCD.x+=GLCD.size;
111E:  MOVF   3A,W
1120:  ADDWF  38,F
....................       y2= GLCD.y + 7*GLCD.size;
1122:  MOVF   3A,W
1124:  MULLW  07
1126:  MOVF   FF3,W
1128:  ADDWF  39,W
112A:  MOVWF  x43
....................       GLCD_UPDATE_COORDINATE(x1,y1, x2,y2);
112C:  MOVFF  440,469
1130:  MOVFF  442,46A
1134:  MOVFF  441,46B
1138:  MOVFF  443,46C
113C:  MOVLB  0
113E:  RCALL  0E7E
....................       return OK;
1140:  MOVLW  00
1142:  MOVWF  01
1144:  RETURN 0
....................  }
....................  
.................... result glcd_spkt_logo_raw(int x) 
.................... { 
....................    unsigned int8 i=0, j=0, k=0,y=0; 
....................    unsigned int16 count=0; 
....................    GLCD_UPDATE_COORDINATE(x,0, x+64,63);
....................    for(j=0;j<64;j++) 
....................       {    
....................          for(;i<64;) 
....................          { 
....................             for(k=8;k>0;k--)
....................             {
....................                glcd_pixel_temp(i+x,j+y,bit_test(GLCD_Logo_DHSPKTTP[count],(k-1))); 
....................                i++; 
....................             } 
....................             count++; 
....................          } 
....................       i=0; 
....................       } 
....................       return OK;
.................... } 
.................... 
.................... result glcd_line(unsigned int8 x1, unsigned int8 y1, unsigned int8 x2, unsigned int8 y2, int1 color)
.................... {
....................    unsigned int16        dy, dx;
....................    signed int8  addx=1, addy=1;
....................    signed int16 P, diff;
....................    unsigned int8 i=0,xt1,xt2,yt1,yt2;
....................    dx = abs((signed int8)(x2 - x1));
....................    dy = abs((signed int8)(y2 - y1));
....................    xt1=x1; xt2=x2;
....................    yt1=y1, yt2=y2;
....................    if(x1 > x2)
....................    {
....................       addx = -1;
....................       xt2=x1;
....................       xt1=x2;
....................    }
....................    if(y1 > y2)
....................    {
....................       addy = -1;
....................       yt2=y1;
....................       yt1=y2;
....................    }
....................    GLCD_UPDATE_COORDINATE(xt1,yt1, xt2,yt2);
....................    if(dx >= dy)
....................    {
....................       dy *= 2;
....................       P = dy - dx;
....................       diff = P - dx;
.................... 
....................       for(; i<=dx; ++i)
....................       {
....................          glcd_pixel_temp(x1, y1, color);
.................... 
....................          if(P < 0)
....................          {
....................             P  += dy;
....................             x1 += addx;
....................          }
....................          else
....................          {
....................             P  += diff;
....................             x1 += addx;
....................             y1 += addy;
....................          }
....................       }
....................    }
....................    else
....................    {
....................       dx *= 2;
....................       P = dx - dy;
....................       diff = P - dy;
.................... 
....................       for(; i<=dy; ++i)
....................       {
....................          glcd_pixel_temp(x1, y1, color);
.................... 
....................          if(P < 0)
....................          {
....................             P  += dx;
....................             y1 += addy;
....................          }
....................          else
....................          {
....................             P  += diff;
....................             x1 += addx;
....................             y1 += addy;
....................          }
....................       }
....................    }
....................    return OK;
.................... }
.................... 
.................... result glcd_rect(unsigned int8 x1, unsigned int8 y1, unsigned int8 x2, unsigned int8 y2, int1 fill, int1 color)
.................... {
....................       unsigned int8  xmin, xmax, ymin, ymax,i;
....................       xmin = x1;
*
0EC8:  MOVFF  45E,464
....................       xmax = x2;
0ECC:  MOVFF  460,465
....................       ymin = y1;
0ED0:  MOVFF  45F,466
....................       ymax = y2;
0ED4:  MOVFF  461,467
....................       if(x1 > x2)                            
0ED8:  MOVLB  4
0EDA:  MOVF   x5E,W
0EDC:  SUBWF  x60,W
0EDE:  BC    0EE8
....................       {
....................          xmin = x2;
0EE0:  MOVFF  460,464
....................          xmax = x1;
0EE4:  MOVFF  45E,465
....................       }
....................       if(y1 > y2)                           
0EE8:  MOVF   x5F,W
0EEA:  SUBWF  x61,W
0EEC:  BC    0EF6
....................       {
....................          ymin = y2;
0EEE:  MOVFF  461,466
....................          ymax = y1;
0EF2:  MOVFF  45F,467
....................       }
....................       if(fill)
0EF6:  MOVF   x62,F
0EF8:  BZ    0F20
....................       {
....................          for(i=ymin; i <= ymax; i++)
0EFA:  MOVFF  466,468
0EFE:  MOVF   x68,W
0F00:  SUBWF  x67,W
0F02:  BNC   0F1E
....................             glcd_horizone_line(xmin, xmax,i, color);
0F04:  MOVFF  464,469
0F08:  MOVFF  465,46A
0F0C:  MOVFF  468,46B
0F10:  MOVFF  463,46C
0F14:  MOVLB  0
0F16:  RCALL  0762
0F18:  MOVLB  4
0F1A:  INCF   x68,F
0F1C:  BRA    0EFE
....................       }
0F1E:  BRA    0F6E
....................       else
....................       {
....................          glcd_vertical_line(xmin, ymin,ymax, color);
0F20:  MOVFF  464,469
0F24:  MOVFF  466,46A
0F28:  MOVFF  467,46B
0F2C:  MOVFF  463,46C
0F30:  MOVLB  0
0F32:  RCALL  0E54
....................          glcd_vertical_line(xmax, ymin,ymax, color);
0F34:  MOVFF  465,469
0F38:  MOVFF  466,46A
0F3C:  MOVFF  467,46B
0F40:  MOVFF  463,46C
0F44:  RCALL  0E54
....................          glcd_horizone_line(x1, x2, y1, color);      // Draw the 4 sides
0F46:  MOVFF  45E,469
0F4A:  MOVFF  460,46A
0F4E:  MOVFF  45F,46B
0F52:  MOVFF  463,46C
0F56:  RCALL  0762
....................          glcd_horizone_line(x1, x2, y2, color);
0F58:  MOVFF  45E,469
0F5C:  MOVFF  460,46A
0F60:  MOVFF  461,46B
0F64:  MOVFF  463,46C
0F68:  CALL   0762
0F6C:  MOVLB  4
....................       }
....................       GLCD_UPDATE_COORDINATE(xmin,ymin, xmax,ymax);
0F6E:  MOVFF  464,469
0F72:  MOVFF  466,46A
0F76:  MOVFF  465,46B
0F7A:  MOVFF  467,46C
0F7E:  MOVLB  0
0F80:  RCALL  0E7E
....................       return OK;
0F82:  MOVLW  00
0F84:  MOVWF  01
0F86:  RETURN 0
.................... }
.................... 
.................... result glcd_bar(unsigned int8 x1, unsigned int8 y1, unsigned int8 x2, unsigned int8 y2, unsigned int8 width, int1 color)
.................... {
....................    unsigned int8         half_width;
....................    signed int16 dy, dx;
....................    signed int8  addx=1, addy=1, j;
....................    signed int16 P, diff, c1, c2;
....................    unsigned int8 i=0,xt1,yt1,xt2,yt2;
....................    dx = abs((signed int8)(x2 - x1));
....................    dy = abs((signed int8)(y2 - y1));
....................    half_width = width/2;
....................    c1 = -(dx*x1 + dy*y1);
....................    c2 = -(dx*x2 + dy*y2);  
....................    xt1=x1-half_width;
....................    xt2=x2+half_width;
....................    yt1=y1-half_width;
....................    yt2=y2+half_width;
....................    if(x1 > x2)
....................    {
....................       signed int16 temp;
....................       temp = c1;
....................       c1 = c2;
....................       c2 = temp;
....................       addx = -1;
....................       xt1=x2-half_width;
....................       xt2=x1+half_width;  
....................    }
....................    if(y1 > y2)
....................    {
....................       signed int16 temp;
....................       temp = c1;
....................       c1 = c2;
....................       c2 = temp;
....................       addy = -1;
....................       yt1=y2-half_width;
....................       yt2=y1+half_width;
....................    }
....................    if(xt1>127)   xt1=0;
....................    if(yt1>127)   yt1=0;
....................    if(xt2>127)   xt2=127;
....................    if(yt2>63)    yt2=63;
....................    GLCD_UPDATE_COORDINATE(xt1,yt1, xt2,yt2);
....................    if(dx >= dy)
....................    {
....................       P = 2*dy - dx;
....................       diff = P - dx;
.................... 
....................       for(i=0; i<=dx; ++i)
....................       {
....................          for(j=-half_width; j<half_width+width%2; ++j)
....................          {
....................                glcd_pixel_temp(x1, y1+j, color);
....................          }
....................          if(P < 0)
....................          {
....................             P  += 2*dy;
....................             x1 += addx;
....................          }
....................          else
....................          {
....................             P  += diff;
....................             x1 += addx;
....................             y1 += addy;
....................          }
....................       }
....................    }
....................    else
....................    {
....................       P = 2*dx - dy;
....................       diff = P - dy;
.................... 
....................       for(i=0; i<=dy; ++i)
....................       {
....................          if(P < 0)
....................          {
....................             P  += 2*dx;
....................             y1 += addy;
....................          }
....................          else
....................          {
....................             P  += diff;
....................             x1 += addx;
....................             y1 += addy;
....................          }
....................          for(j=-half_width; j<half_width+width%2; ++j)
....................          {
....................                glcd_pixel_temp(x1+j, y1, color);
....................          }
....................       }
....................    }
....................    return OK;
.................... }
.................... 
.................... result glcd_circle(unsigned int8 x, unsigned int8 y, unsigned int8 radius, int1 fill, int1 color)
.................... {
....................    unsigned int8 xt1,xt2, yt1, yt2;
....................    signed int8  a, b, P;
....................    a = 0;
....................    b = radius;
....................    P = 1 - radius;
....................    do
....................    {
....................       if(fill)
....................       {
....................          glcd_horizone_line(x-a, x+a, y+b, color);
....................          glcd_horizone_line(x-a, x+a, y-b, color);
....................          glcd_horizone_line(x-b, x+b, y+a, color);
....................          glcd_horizone_line(x-b, x+b, y-a, color);  
....................       }
....................       else
....................       {
....................          glcd_pixel_temp(a+x, b+y, color);
....................          glcd_pixel_temp(b+x, a+y, color);
....................          glcd_pixel_temp(x-a, b+y, color);
....................          glcd_pixel_temp(x-b, a+y, color);
....................          glcd_pixel_temp(b+x, y-a, color);
....................          glcd_pixel_temp(a+x, y-b, color);
....................          glcd_pixel_temp(x-a, y-b, color);
....................          glcd_pixel_temp(x-b, y-a, color);
....................       }
.................... 
....................       if(P < 0)
....................          P += 3 + 2 * a++;
....................       else
....................          P += 5 + 2 * (a++ - b--);
....................     } while(a <= b);
....................     xt1 = x-radius;
....................     xt2 = x+radius;
....................     yt1 = y-radius;
....................     yt2 = y+radius;
....................     if(xt1>127)   xt1=0;
....................     if(yt1>127)   yt1=0;
....................     if(xt2>127)   xt2=127;
....................     if(yt2>63)    yt2=63;
....................     GLCD_UPDATE_COORDINATE(xt1,yt1, xt2,yt2);
....................     return OK;
.................... }
.................... result glcd_triangle(signed int16 x1,signed int16 y1, signed int16 x2, signed int16 y2, signed int16 x3, signed int16 y3,int1 fill,int1 color)
.................... {
....................     unsigned int8 xt1, xt2, yt11,yt22;
....................     signed int16 x[3],y[3],n,yt1,yt2,yt,dx1,dx2,dx3,dy1,dy2,dy3; 
....................     signed int16 sh1,sh2,sh3;
....................     x[0]=x1; x[1]=x2; x[2]=x3;y[0]=y1; y[1]=y2; y[2]=y3;
....................     if(x[0]>x[1]){yt=x[0];x[0]=x[1];x[1]=yt;yt=y[0];y[0]=y[1];y[1]=yt;}
....................     if(x[0]>x[2]){yt=x[0];x[0]=x[2];x[2]=yt;yt=y[0];y[0]=y[2];y[2]=yt;}
....................     if(x[1]>x[2]){yt=x[1];x[1]=x[2];x[2]=yt;yt=y[1];y[1]=y[2];y[2]=yt;}
....................     dx1= x[2]-x[0]; dx2= x[1]-x[0];dx3=x[2]-x[1];
....................     dy1= y[2]-y[0]; dy2= y[1]-y[0];dy3=y[2]-y[1];
....................     sh1=x[2]*y[0] - x[0]*y[2]; sh2=x[1]*y[0] - x[0]*y[1]; sh3=x[2]*y[1] - x[1]*y[2];
....................     if(fill)
....................     {
....................         for(n=x[0] ; n<x[1]; n++)
....................           {
....................               yt1= (dy1*n + sh1)/dx1;
....................               yt2= (dy2*n + sh2)/dx2;
....................               if(yt2<yt1){yt= yt1; yt1=yt2; yt2=yt;}
....................               glcd_vertical_line(n,yt1,yt2,color);
....................           }
....................           for(n=x[1] ; n<x[2]; n++)
....................           {
....................               yt1= (dy1*n + sh1)/dx1;
....................               yt2= (dy3*n + sh3)/dx3;
....................               if(yt2<yt1){yt= yt1; yt1=yt2; yt2=yt;}
....................               glcd_vertical_line(n,yt1,yt2,color);
....................           }  
....................     }
....................     else 
....................     {
....................          glcd_line(x1,y1,x2,y2,color);
....................          glcd_line(x1,y1,x3,y3,color);
....................          glcd_line(x2,y2,x3,y3,color);
....................     }
....................     xt1 = x[0];
....................     xt2 = x[2];
....................     if(y[0]>y[1])yt22= y[0]; else yt22 = y[1];
....................     if(yt22<y[2]) yt22 = y[2]; 
....................     if(y[0]<y[1]) yt11= y[0]; else yt11 = y[1];
....................     if(yt11>y[2])yt11 = y[2];
....................     GLCD_UPDATE_COORDINATE(xt1,yt11, xt2,yt22);   
....................     return OK;
.................... }
.................... result glcd_data(int8 data)
.................... {
....................       write_glcd128x64(0x17,data);
*
05B4:  MOVLW  17
05B6:  MOVLB  4
05B8:  MOVWF  x4F
05BA:  MOVFF  44E,450
05BE:  MOVLB  0
05C0:  RCALL  03DA
....................       write_glcd128x64(0x13,data);
05C2:  MOVLW  13
05C4:  MOVLB  4
05C6:  MOVWF  x4F
05C8:  MOVFF  44E,450
05CC:  MOVLB  0
05CE:  RCALL  03DA
....................       delay_us(9);
05D0:  MOVLW  0E
05D2:  MOVWF  00
05D4:  DECFSZ 00,F
05D6:  BRA    05D4
05D8:  BRA    05DA
....................       return OK;
05DA:  MOVLW  00
05DC:  MOVWF  01
05DE:  RETURN 0
.................... }
.................... result glcd_command(int8 data)
.................... {
....................       write_glcd128x64(0x07,data);
*
04C4:  MOVLW  07
04C6:  MOVLB  4
04C8:  MOVWF  x4F
04CA:  MOVFF  44C,450
04CE:  MOVLB  0
04D0:  RCALL  03DA
....................       write_glcd128x64(0x03,data);
04D2:  MOVLW  03
04D4:  MOVLB  4
04D6:  MOVWF  x4F
04D8:  MOVFF  44C,450
04DC:  MOVLB  0
04DE:  RCALL  03DA
....................       delay_us(2);
04E0:  MOVLW  03
04E2:  MOVWF  00
04E4:  DECFSZ 00,F
04E6:  BRA    04E4
....................       return OK;
04E8:  MOVLW  00
04EA:  MOVWF  01
04EC:  RETURN 0
.................... }
.................... result glcd_setup()
.................... {
....................       GLCD_COMMAND(0x30);    DELAY_mS(1);   
*
071A:  MOVLW  30
071C:  MOVLB  4
071E:  MOVWF  x4C
0720:  MOVLB  0
0722:  RCALL  04C4
0724:  MOVLW  01
0726:  MOVLB  4
0728:  MOVWF  x48
072A:  MOVLB  0
072C:  RCALL  0308
....................       GLCD_COMMAND(0x01);    DELAY_MS(10);
072E:  MOVLW  01
0730:  MOVLB  4
0732:  MOVWF  x4C
0734:  MOVLB  0
0736:  RCALL  04C4
0738:  MOVLW  0A
073A:  MOVLB  4
073C:  MOVWF  x48
073E:  MOVLB  0
0740:  RCALL  0308
....................       GLCD_COMMAND(0x36);     
0742:  MOVLW  36
0744:  MOVLB  4
0746:  MOVWF  x4C
0748:  MOVLB  0
074A:  RCALL  04C4
....................       glcd_clear(0);  
074C:  MOVLB  4
074E:  CLRF   x46
0750:  MOVLB  0
0752:  BRA    04EE
....................       glcd_update();
0754:  RCALL  05E0
....................       GLCD.tt_update=0;
0756:  BCF    3B.2
....................       GLCD.tt_text=0;
0758:  BCF    3B.1
....................       return OK;
075A:  MOVLW  00
075C:  MOVWF  01
075E:  GOTO   1BD0 (RETURN)
.................... }
.................... #endif
.................... #endif
.................... 
.................... void level_display()        // Hien thi cap do dong co - xem lai bai EXAMPLE_GCLD.c
.................... {
....................      glcd_text_setup(9,13,3,1,1);
*
12A6:  MOVLB  4
12A8:  CLRF   x47
12AA:  MOVLW  09
12AC:  MOVWF  x46
12AE:  CLRF   x49
12B0:  MOVLW  0D
12B2:  MOVWF  x48
12B4:  MOVLW  03
12B6:  MOVWF  x4A
12B8:  MOVLW  01
12BA:  MOVWF  x4B
12BC:  MOVWF  x4C
12BE:  MOVLB  0
12C0:  RCALL  0F88
....................      printf(glcd_text,"%02lu",dcmotor.duty/100);
12C2:  MOVFF  24,447
12C6:  MOVFF  23,446
12CA:  MOVLB  4
12CC:  CLRF   x49
12CE:  MOVLW  64
12D0:  MOVWF  x48
12D2:  MOVLB  0
12D4:  BRA    1166
12D6:  MOVFF  02,447
12DA:  MOVFF  01,446
12DE:  MOVLW  0B
12E0:  MOVWF  FE9
12E2:  MOVFF  02,449
12E6:  MOVFF  01,448
12EA:  RCALL  11E0
....................      glcd_update();
12EC:  CALL   05E0
12F0:  RETURN 0
.................... }
.................... void speed_display()       // Hien thi toc do quay cua dong co 
.................... {
....................      glcd_text_setup(54,13,3,1,1);
*
1AAA:  MOVLB  4
1AAC:  CLRF   x47
1AAE:  MOVLW  36
1AB0:  MOVWF  x46
1AB2:  CLRF   x49
1AB4:  MOVLW  0D
1AB6:  MOVWF  x48
1AB8:  MOVLW  03
1ABA:  MOVWF  x4A
1ABC:  MOVLW  01
1ABE:  MOVWF  x4B
1AC0:  MOVWF  x4C
1AC2:  MOVLB  0
1AC4:  CALL   0F88
....................      printf(glcd_text,"%04lu",dcmotor.speed);
1AC8:  MOVLW  09
1ACA:  MOVWF  FE9
1ACC:  MOVFF  27,449
1AD0:  MOVFF  26,448
1AD4:  CALL   11E0
....................      glcd_update(); 
1AD8:  CALL   05E0
1ADC:  GOTO   1D22 (RETURN)
.................... }
.................... void status_display()       // Hien thi trang thai quay cua dong co
.................... {
....................      glcd_text_setup(43,52,1,0,1);
1AE0:  MOVLB  4
1AE2:  CLRF   x47
1AE4:  MOVLW  2B
1AE6:  MOVWF  x46
1AE8:  CLRF   x49
1AEA:  MOVLW  34
1AEC:  MOVWF  x48
1AEE:  MOVLW  01
1AF0:  MOVWF  x4A
1AF2:  CLRF   x4B
1AF4:  MOVWF  x4C
1AF6:  MOVLB  0
1AF8:  CALL   0F88
....................      if(dcmotor.duty==0)                            glcd_text("  STOP ");
1AFC:  MOVF   23,F
1AFE:  BNZ   1B12
1B00:  MOVF   24,F
1B02:  BNZ   1B12
1B04:  MOVLW  00
1B06:  MOVWF  FF6
1B08:  MOVLW  02
1B0A:  MOVWF  FF7
1B0C:  CALL   1146
1B10:  BRA    1B30
....................      else if(dcmotor.direct==dcmotor_direct_forward)glcd_text("FORWARD"); 
1B12:  BTFSS  25.0
1B14:  BRA    1B24
1B16:  MOVLW  08
1B18:  MOVWF  FF6
1B1A:  MOVLW  02
1B1C:  MOVWF  FF7
1B1E:  CALL   1146
1B22:  BRA    1B30
....................      else                                           glcd_text("REVERSE"); 
1B24:  MOVLW  10
1B26:  MOVWF  FF6
1B28:  MOVLW  02
1B2A:  MOVWF  FF7
1B2C:  CALL   1146
....................      glcd_update();
1B30:  CALL   05E0
1B34:  GOTO   1D24 (RETURN)
.................... }
.................... void main()
1B38:  CLRF   FF8
1B3A:  BCF    FD0.7
1B3C:  BSF    FB8.3
1B3E:  MOVLW  08
1B40:  MOVWF  FAF
1B42:  MOVLW  02
1B44:  MOVWF  FB0
1B46:  MOVLW  A6
1B48:  MOVWF  FAC
1B4A:  MOVLW  90
1B4C:  MOVWF  FAB
1B4E:  MOVLB  4
1B50:  CLRF   x45
1B52:  CLRF   x44
1B54:  MOVF   FC1,W
1B56:  ANDLW  C0
1B58:  IORLW  0F
1B5A:  MOVWF  FC1
1B5C:  MOVLW  07
1B5E:  MOVWF  FB4
1B60:  BCF    32.0
1B62:  BRA    1B88
1B64:  DATA 06,40
1B66:  DATA 04,00
1B68:  DATA 0E,40
1B6A:  DATA 12,FF
1B6C:  DATA 05,C0
1B6E:  DATA 00,01
1B70:  DATA 80,01
1B72:  DATA 04,C0
1B74:  DATA 00,01
1B76:  DATA 80,01
1B78:  DATA 07,C0
1B7A:  DATA 00,05
1B7C:  DATA 40,33
1B7E:  DATA 00,04
1B80:  DATA 04,40
1B82:  DATA 00,00
1B84:  DATA 00,00
1B86:  DATA 00,00
1B88:  MOVLW  00
1B8A:  MOVWF  FF8
1B8C:  MOVLW  1B
1B8E:  MOVWF  FF7
1B90:  MOVLW  64
1B92:  MOVWF  FF6
1B94:  TBLRD*+
1B96:  MOVF   FF5,W
1B98:  MOVWF  00
1B9A:  XORLW  00
1B9C:  BZ    1BC4
1B9E:  TBLRD*+
1BA0:  MOVF   FF5,W
1BA2:  MOVWF  01
1BA4:  BTFSC  FE8.7
1BA6:  BRA    1BB2
1BA8:  ANDLW  3F
1BAA:  MOVWF  FEA
1BAC:  TBLRD*+
1BAE:  MOVFF  FF5,FE9
1BB2:  BTFSC  01.6
1BB4:  TBLRD*+
1BB6:  BTFSS  01.6
1BB8:  TBLRD*+
1BBA:  MOVFF  FF5,FEE
1BBE:  DCFSNZ 00,F
1BC0:  BRA    1B94
1BC2:  BRA    1BB6
1BC4:  CLRF   FF8
.................... { 
....................       system_init();  
1BC6:  MOVLB  0
1BC8:  GOTO   044A
....................       glcd_setup();
1BCC:  GOTO   071A
....................       glcd_rect(0,3,47,40,0,1);
1BD0:  MOVLB  4
1BD2:  CLRF   x5E
1BD4:  MOVLW  03
1BD6:  MOVWF  x5F
1BD8:  MOVLW  2F
1BDA:  MOVWF  x60
1BDC:  MOVLW  28
1BDE:  MOVWF  x61
1BE0:  CLRF   x62
1BE2:  MOVLW  01
1BE4:  MOVWF  x63
1BE6:  MOVLB  0
1BE8:  CALL   0EC8
....................       glcd_text_setup(5,0,1,1,1);
1BEC:  MOVLB  4
1BEE:  CLRF   x47
1BF0:  MOVLW  05
1BF2:  MOVWF  x46
1BF4:  CLRF   x49
1BF6:  CLRF   x48
1BF8:  MOVLW  01
1BFA:  MOVWF  x4A
1BFC:  MOVWF  x4B
1BFE:  MOVWF  x4C
1C00:  MOVLB  0
1C02:  CALL   0F88
....................       glcd_text(" LEVEL");
1C06:  MOVLW  18
1C08:  MOVWF  FF6
1C0A:  MOVLW  02
1C0C:  MOVWF  FF7
1C0E:  CALL   1146
....................       glcd_update();
1C12:  CALL   05E0
....................       glcd_rect(50,3,127,40,0,1);
1C16:  MOVLW  32
1C18:  MOVLB  4
1C1A:  MOVWF  x5E
1C1C:  MOVLW  03
1C1E:  MOVWF  x5F
1C20:  MOVLW  7F
1C22:  MOVWF  x60
1C24:  MOVLW  28
1C26:  MOVWF  x61
1C28:  CLRF   x62
1C2A:  MOVLW  01
1C2C:  MOVWF  x63
1C2E:  MOVLB  0
1C30:  CALL   0EC8
....................       glcd_text_setup(71,0,1,1,1);
1C34:  MOVLB  4
1C36:  CLRF   x47
1C38:  MOVLW  47
1C3A:  MOVWF  x46
1C3C:  CLRF   x49
1C3E:  CLRF   x48
1C40:  MOVLW  01
1C42:  MOVWF  x4A
1C44:  MOVWF  x4B
1C46:  MOVWF  x4C
1C48:  MOVLB  0
1C4A:  CALL   0F88
....................       glcd_text(" SPEED");
1C4E:  MOVLW  20
1C50:  MOVWF  FF6
1C52:  MOVLW  02
1C54:  MOVWF  FF7
1C56:  CALL   1146
....................       glcd_update();
1C5A:  CALL   05E0
....................       glcd_rect(0,45,127,63,1,1);
1C5E:  MOVLB  4
1C60:  CLRF   x5E
1C62:  MOVLW  2D
1C64:  MOVWF  x5F
1C66:  MOVLW  7F
1C68:  MOVWF  x60
1C6A:  MOVLW  3F
1C6C:  MOVWF  x61
1C6E:  MOVLW  01
1C70:  MOVWF  x62
1C72:  MOVWF  x63
1C74:  MOVLB  0
1C76:  CALL   0EC8
....................       glcd_update();
1C7A:  CALL   05E0
....................       dcmotor.duty=800; 
1C7E:  MOVLW  03
1C80:  MOVWF  24
1C82:  MOVLW  20
1C84:  MOVWF  23
....................       level_display();
1C86:  CALL   12A6
....................       
....................       while(true)
....................       {    // 1. Nhan BT0 de tang toc
....................            if((inputcd(BT0)==0)&& (dcmotor.duty<1000)){ dcmotor.duty+= 100;     level_display();}
1C8A:  MOVLW  7C
1C8C:  MOVLB  4
1C8E:  MOVWF  x47
1C90:  MOVLW  0D
1C92:  MOVWF  x46
1C94:  MOVLB  0
1C96:  RCALL  14EE
1C98:  MOVF   01,F
1C9A:  BNZ   1CBA
1C9C:  BTFSC  24.7
1C9E:  BRA    1CAE
1CA0:  MOVF   24,W
1CA2:  SUBLW  03
1CA4:  BNC   1CBA
1CA6:  BNZ   1CAE
1CA8:  MOVF   23,W
1CAA:  SUBLW  E7
1CAC:  BNC   1CBA
1CAE:  MOVLW  64
1CB0:  ADDWF  23,F
1CB2:  MOVLW  00
1CB4:  ADDWFC 24,F
1CB6:  CALL   12A6
....................            // 2. Nhan BT1 de giam toc
....................            if((inputcd(BT1)==0)&& (dcmotor.duty>0))   { dcmotor.duty-= 100;     level_display();}
1CBA:  MOVLW  7C
1CBC:  MOVLB  4
1CBE:  MOVWF  x47
1CC0:  MOVLW  0C
1CC2:  MOVWF  x46
1CC4:  MOVLB  0
1CC6:  RCALL  14EE
1CC8:  MOVF   01,F
1CCA:  BNZ   1CE6
1CCC:  BTFSC  24.7
1CCE:  BRA    1CE6
1CD0:  MOVF   24,F
1CD2:  BNZ   1CDA
1CD4:  MOVF   23,W
1CD6:  SUBLW  00
1CD8:  BC    1CE6
1CDA:  MOVLW  64
1CDC:  SUBWF  23,F
1CDE:  MOVLW  00
1CE0:  SUBWFB 24,F
1CE2:  CALL   12A6
....................            // 3. Nhan BT2 de dao chieu dong co
....................            if(inputcd(BT2)==0) dcmotor.direct=!dcmotor.direct;
1CE6:  MOVLW  7C
1CE8:  MOVLB  4
1CEA:  MOVWF  x47
1CEC:  MOVLW  0B
1CEE:  MOVWF  x46
1CF0:  MOVLB  0
1CF2:  CALL   14EE
1CF6:  MOVF   01,F
1CF8:  BNZ   1CFC
1CFA:  BTG    25.0
....................            // 4. Nhan BT2 de dung dong co
....................            if(inputcd(BT3)==0)                        {dcmotor.duty=0;          level_display();}
1CFC:  MOVLW  7C
1CFE:  MOVLB  4
1D00:  MOVWF  x47
1D02:  MOVLW  0A
1D04:  MOVWF  x46
1D06:  MOVLB  0
1D08:  CALL   14EE
1D0C:  MOVF   01,F
1D0E:  BNZ   1D18
1D10:  CLRF   24
1D12:  CLRF   23
1D14:  CALL   12A6
....................            dcmotor_control();   // cap nhat cac gia tri dieu khien
1D18:  BRA    189C
....................            //5. Do toc do dong co
....................            if(dcmotor_read_speed()==OK) speed_display();
1D1A:  BRA    19C4
1D1C:  MOVF   01,F
1D1E:  BTFSC  FD8.2
1D20:  BRA    1AAA
....................            status_display();         
1D22:  BRA    1AE0
1D24:  BRA    1C8A
....................       }
.................... }
1D26:  SLEEP 

Configuration Fuses:
   Word  1: CC27   PLL12 CPUDIV1 USBDIV HS FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
