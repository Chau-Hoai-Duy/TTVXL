CCS PCH C Compiler, Version 5.101, 43599               30-Jan-23 20:26

               Filename:   C:\TTVXL\TTVXL\Thuc Hanh\EXAMPLE_3_KEY4x4.lst

               ROM used:   1752 bytes (1%)
                           Largest free fragment is 65536
               RAM used:   43 (1%) at main() level
                           62 (2%) worst case
               Stack used: 0 locations
               Stack size: 31

*
00000:  GOTO   062A
.................... /************************************ Yeu cau *******************************************************************
....................  1. Nhan cac phim tu 0 den 12 de bat hoac tat cac LED tu 0-12
....................  2. Nhan phim 15 de cho phep 16 LED tan cung ben trai sang dan lien tuc
....................  3. Nhan giu phim 13 de tang bien dem  va hien thi LED 7 doan
....................  4. Nhan giu phim 14 de giam bien dem  va hien thi LED 7 doan
....................  
.................... ********************************* Cac lenh lien quan ************************************************************
.................... 1.Khi tac vu xu ly LAP DI LAP LAI LIEN TUC (vd:16 LED sang dan lien tuc nhu yeu cau 2)      
....................    . Ta thuc hien theo mau:
....................               ----------------------------------------------
....................                        int1 tt=0;
....................                        if(key4x4_read()==OK)
....................                         {
....................                               if(key4x4.key== ?) tt=1;
....................                         }
....................                        if(tt)
....................                         {
....................                             thuc thi tac vu o day
....................                         }
....................               ----------------------------------------------                                    
.................... 2.Khi tac vu xu ly KHONG LAP DI LAP LAI LIEN TUC(vd:Nhan cac phim tu 0 den 12 de bat hoac tat cac LED tu 0-12 nhu yeu cau 1)      
....................    . Ta thuc hien theo mau: 
....................               ----------------------------------------------      
....................                         if(key4x4_read()==OK)
....................                         {
....................                               if(key4x4.key== ?) 
....................                               {
....................                                     thuc thi tac vu o day
....................                               }
....................                         }
....................               ----------------------------------------------
.................... 3.Doi voi tac vu nhan giu ta thuc hien theo mau: 
....................               ---------------------------------------------- 
....................                       if(key4x4_read()==OK)
....................                         {
....................                               if(key4x4.key== ?) 
....................                               {
....................                                     thuc thi tac vu o day
....................                               }
....................                         }    
....................               ---------------------------------------------- 
.................... 4.Khi ban phim dap ung khong tot (nhan giu lau moi duoc)
....................    .Ta goi chuong trinh quet phim va xu ly phim nhan trong cac lenh vong lap 
....................    .Bo cac ham delay mat nhieu thoi gian va thay vao do la goi ham quet phim va xu ly nhieu lan 
....................       
.................... *********************************** Chuong trinh ************************************************************/
.................... //!#define   BOARD     D501
.................... //!#include<tv_boards.c> 
.................... //!#include<tv_key4x4.c>
.................... //!signed int8 i;
.................... //!unsigned int8 dem=0;
.................... //!unsigned int1 tt=0;
.................... //!void sangdan16led()                
.................... //!{
.................... //!     for(i=16;i>=0;i--)
.................... //!      {
.................... //!            led32.ledx16[1]=0xffff>>i;
.................... //!            led32_display(); delay_ms(200);
.................... //!      }
.................... //!}
.................... //!void main()
.................... //!{
.................... //!      system_init();  
.................... //!      d7seg.led[2] = m7d[dem/100%10];      
.................... //!      d7seg.led[1] = m7d[dem/10%10];        
.................... //!      d7seg.led[0] = m7d[dem/1%10];       
.................... //!      d7seg_display();
.................... //!      while(true)
.................... //!      {     
.................... //!            if(key4x4_read()==OK)
.................... //!            {     //1. Nhan cac phim tu 0 den 12 de bat hoac tat cac LED tu 0-12
.................... //!                  if(key4x4.key<13) led32.ledx16[0]^=((int16)0x01<<key4x4.key);
.................... //!                  led32_display();
.................... //!                  
.................... //!                  //2. Nhan phim 15 de cho phep 16 LED tan cung ben trai sang dan lien tuc
.................... //!                  if(key4x4.key==15)tt=1;
.................... //!                  
.................... //!                  //3. Nhan giu phim 13 de tang bien dem  va hien thi LED 7 doan
.................... //!                  if(key4x4.key==13)dem++;   
.................... //!                  
.................... //!                  //4. Nhan giu phim 14 de giam bien dem  va hien thi LED 7 doan
.................... //!                  if(key4x4.key==14)dem--; 
.................... //!
.................... //!                  // hien thi bien dem tren LED 7 doan->tham khao example_d7seg
.................... //!                  d7seg.led[2] = m7d[dem/100%10];      
.................... //!                  d7seg.led[1] = m7d[dem/10%10];        
.................... //!                  d7seg.led[0] = m7d[dem/1%10];       
.................... //!                  d7seg_display();
.................... //!            }
.................... //!            
.................... //!            //2. Nhan phim 15 de cho phep 16 LED tan cung ben trai sang dan lien tuc
.................... //!            if(tt==1)   
.................... //!            {
.................... //!               sangdan16led() ;
.................... //!            }
.................... //!      }
.................... //!}
.................... 
.................... /*Nhan thay neu ta viet chuong trinh nhu tren thi khi 16 LED don dang sang dan se gay ra tri hoan 
.................... nhieu 200*17 = 3.7s. Trong 3.7s nay neu ta nhan nut se khong tac dung nen ta se khac phuc theo 
.................... huong dan (4) o ben tren nhu sau:  
.................... ********************************** Chuong trinh hoan chinh****************************************************/
.................... //#define   BOARD     D503
.................... #include<tv_boards.c>  
.................... #ifndef    __TV_BOARDS_C__
.................... #define    __TV_BOARDS_C__
.................... #define    D401          1
.................... #define    D501          2
.................... #define    D503          3
.................... #define    MOPHONG       4
.................... #ifndef    BOARD
.................... #define    BOARD         MOPHONG
.................... #endif
.................... #if  BOARD ==  D401
.................... #include <TV_D401_TH.C>
.................... 
.................... #elif  BOARD ==  D501
.................... #include <TV_D501_TH.C>
....................  
.................... #elif  BOARD ==  D503
.................... #include <TV_D501_TH.C>
.................... 
.................... #else 
.................... #include <TV_MOPHONG.C>
.................... #ifndef    __TV_MOPHONG_C__
.................... #define    __TV_MOPHONG_C__
.................... #include<TV_MOPHONG.h>
.................... #ifndef    __TV_MOPHONG_H__
.................... #define    __TV_MOPHONG_H__
.................... #include    <18f6722.h>
.................... //////////// Standard Header file for the PIC18F6722 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F6722
00004:  CLRF   FF7
00006:  ADDLW  18
00008:  MOVWF  FF6
0000A:  MOVLW  00
0000C:  ADDWFC FF7,F
0000E:  MOVLW  00
00010:  MOVWF  FF8
00012:  TBLRD*+
00014:  MOVF   FF5,W
00016:  RETURN 0
00018:  DATA C0,F9
0001A:  DATA A4,B0
0001C:  DATA 99,92
0001E:  DATA 82,F8
00020:  DATA 80,90
00022:  DATA 88,83
00024:  DATA C6,A1
00026:  DATA 86,7F
00028:  CLRF   FF7
0002A:  ADDLW  3C
0002C:  MOVWF  FF6
0002E:  MOVLW  00
00030:  ADDWFC FF7,F
00032:  MOVLW  00
00034:  MOVWF  FF8
00036:  TBLRD*+
00038:  MOVF   FF5,W
0003A:  RETURN 0
0003C:  DATA EF,DF
0003E:  DATA BF,7F
*
00212:  MOVF   2C,W
00214:  CLRF   01
00216:  SUBWF  2B,W
00218:  BC    0220
0021A:  MOVFF  2B,00
0021E:  BRA    0238
00220:  CLRF   00
00222:  MOVLW  08
00224:  MOVWF  2D
00226:  RLCF   2B,F
00228:  RLCF   00,F
0022A:  MOVF   2C,W
0022C:  SUBWF  00,W
0022E:  BTFSC  FD8.0
00230:  MOVWF  00
00232:  RLCF   01,F
00234:  DECFSZ 2D,F
00236:  BRA    0226
00238:  RETURN 0
*
002E2:  BTFSC  FD8.1
002E4:  BRA    02EC
002E6:  CLRF   FEA
002E8:  MOVLW  36
002EA:  MOVWF  FE9
002EC:  CLRF   00
002EE:  CLRF   01
002F0:  CLRF   02
002F2:  CLRF   03
002F4:  CLRF   36
002F6:  CLRF   37
002F8:  CLRF   38
002FA:  CLRF   39
002FC:  MOVF   35,W
002FE:  IORWF  34,W
00300:  IORWF  33,W
00302:  IORWF  32,W
00304:  BZ    035E
00306:  MOVLW  20
00308:  MOVWF  3A
0030A:  BCF    FD8.0
0030C:  RLCF   2E,F
0030E:  RLCF   2F,F
00310:  RLCF   30,F
00312:  RLCF   31,F
00314:  RLCF   36,F
00316:  RLCF   37,F
00318:  RLCF   38,F
0031A:  RLCF   39,F
0031C:  MOVF   35,W
0031E:  SUBWF  39,W
00320:  BNZ   0332
00322:  MOVF   34,W
00324:  SUBWF  38,W
00326:  BNZ   0332
00328:  MOVF   33,W
0032A:  SUBWF  37,W
0032C:  BNZ   0332
0032E:  MOVF   32,W
00330:  SUBWF  36,W
00332:  BNC   0352
00334:  MOVF   32,W
00336:  SUBWF  36,F
00338:  MOVF   33,W
0033A:  BTFSS  FD8.0
0033C:  INCFSZ 33,W
0033E:  SUBWF  37,F
00340:  MOVF   34,W
00342:  BTFSS  FD8.0
00344:  INCFSZ 34,W
00346:  SUBWF  38,F
00348:  MOVF   35,W
0034A:  BTFSS  FD8.0
0034C:  INCFSZ 35,W
0034E:  SUBWF  39,F
00350:  BSF    FD8.0
00352:  RLCF   00,F
00354:  RLCF   01,F
00356:  RLCF   02,F
00358:  RLCF   03,F
0035A:  DECFSZ 3A,F
0035C:  BRA    030A
0035E:  MOVFF  36,FEF
00362:  MOVFF  37,FEC
00366:  MOVFF  38,FEC
0036A:  MOVFF  39,FEC
0036E:  RETURN 0
*
0052E:  ADDWF  FE8,W
00530:  CLRF   FF7
00532:  RLCF   FF7,F
00534:  ADDLW  4F
00536:  MOVWF  FF6
00538:  MOVLW  05
0053A:  ADDWFC FF7,F
0053C:  MOVLW  00
0053E:  MOVWF  FF8
00540:  MOVWF  FFB
00542:  TBLRD*-
00544:  MOVF   FF5,W
00546:  MOVWF  FFA
00548:  TBLRD*
0054A:  MOVF   FF5,W
0054C:  MOVWF  FF9
0054E:  DATA 68,04
00550:  DATA 7E,04
00552:  DATA B8,04
00554:  DATA F2,04
.................... 
.................... #list
.................... 
.................... #device     adc =10
.................... #fuses      hs,PUT, NOWDT
.................... #use        delay(clock=20M)
*
00040:  CLRF   FEA
00042:  MOVLW  2C
00044:  MOVWF  FE9
00046:  MOVF   FEF,W
00048:  BZ    0064
0004A:  MOVLW  06
0004C:  MOVWF  01
0004E:  CLRF   00
00050:  DECFSZ 00,F
00052:  BRA    0050
00054:  DECFSZ 01,F
00056:  BRA    004E
00058:  MOVLW  7B
0005A:  MOVWF  00
0005C:  DECFSZ 00,F
0005E:  BRA    005C
00060:  DECFSZ FEF,F
00062:  BRA    004A
00064:  RETURN 0
.................... #USE        SPI(SPI2,STREAM = SPI_2,baud=5000000)
.................... #include    <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float32)(unsigned int16)y;
.................... 
....................  else if (y < 10000000.0)
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
....................       res = 32768.0*(float32)l;
....................       res += (float32)(unsigned int16)y;
....................    }
.................... 
....................  else
....................   res = y;
.................... 
....................  y = y - (float32)(unsigned int16)y;
.................... 
....................  if (s)
....................   res = -res;
.................... 
....................  if (y != 0)
....................  {
....................   if (s == 1 && n == 0)
....................    res -= 1.0;
.................... 
....................   if (s == 0 && n == 1)
....................    res += 1.0;
....................  }
....................  if (x == 0)
....................     res = 0;
.................... 
....................  return (res);
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl[0]*y2 + pl[1];
.................... 
....................       r = ql[0]*y2 + ql[1];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
....................          r = -(float32)-n;
....................       else
....................          r = (float32)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... #bit     TIM3IF           = 0xFA1.1
.................... #define  analog_pins        an0_to_an3
.................... #define  lm35a_channel      0
.................... #define  lm35b_channel      1
.................... #define  gp2d12_channel     2
.................... #define  photoresis_channel 3
.................... #define  TOUCH_PIN        pin_c6
.................... #define  DHT11_PIN        pin_c5
.................... #define  HX711_DO         pin_d2
.................... #define  HX711_CLK        pin_d3
.................... #define  DCMOTOR_IN1      PIN_G0
.................... #define  STEPMOTOR_IN0    PIN_G1
.................... #define  STEPMOTOR_IN1    PIN_G2
.................... #define  STEPMOTOR_IN2    PIN_G3
.................... #define  STEPMOTOR_IN3    PIN_G4
.................... #define  soft_i2c_sda     pin_c4
.................... #define  soft_i2c_scl     pin_c3 
.................... #define  SRF04_TRIGER     PIN_C7
.................... #define  LCD_RS           PIN_F0
.................... #define  LCD_E            PIN_F5
.................... #define  OUTPUT_LCD       OUTPUT_E
.................... #define  LED32_RCK        pin_d5
.................... #define  D7SEG_RCK        pin_d7
.................... #define  S7SEG_RCK        pin_a5
.................... #define  TRIAC_PIN        Pin_f6
.................... #define  BUZZER_PIN       pin_f7
.................... #define  GLCD_CSA         PIN_F1   
.................... #define  GLCD_CSB         PIN_F2   
.................... #define  GLCD_CSC         PIN_F3                       
.................... #define  GLCD_RS          PIN_F0
.................... #define  GLCD_E           PIN_F4
.................... #define  output_glcd      output_e
.................... 
.................... //***** SRF04 using CCP1 (RC2) pin as ECHO pin *******************
.................... #DEFINE  BT0             PIN_b4
.................... #DEFINE  BT1             PIN_b5
.................... #DEFINE  BT2             PIN_b6
.................... #DEFINE  BT3             PIN_b7
.................... #DEFINE  ON              BT0 
.................... #DEFINE  UP              BT0  
.................... #DEFINE  ON1             BT0 
.................... #DEFINE  OFF             BT1
.................... #DEFINE  DW              BT1
.................... #DEFINE  OFF1            BT1
.................... #DEFINE  INV             BT2
.................... #DEFINE  ON2             BT2
.................... #DEFINE  CLR             BT2
.................... #DEFINE  MOD             BT3
.................... #DEFINE  STOP            BT3    
.................... #DEFINE  OFF2            BT3
.................... typedef enum 
.................... {
....................       OK    = 0,
....................       ERROR = 1,
....................       BUSY  = 2
.................... }result;
.................... typedef struct
.................... {
....................       unsigned int32 timeline;
.................... }DELAY_STRUCT;
.................... DELAY_STRUCT  delay=0;
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxx Module 32 LED don xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... typedef union 
.................... { 
....................   int1           ledx1[32];
....................   unsigned int8  ledx8[4];
....................   unsigned int16 ledx16[2];
....................   unsigned int32 ledx32; 
.................... } LED32_UNION;
.................... LED32_UNION led32;
.................... result led32_display(void);
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxx Module 7 DOAN TT xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... const unsigned int8 m7d[16]= {0XC0,0XF9,0xA4,0XB0,0X99,0X92,0X82,0XF8,0X80,0X90,0x88, 0x83, 0xC6, 0xA1, 0x86, 0x7f};
.................... typedef struct 
.................... { 
....................   unsigned int8   led[8];  
.................... } D7SEG_STRUCT; 
.................... D7SEG_STRUCT    d7seg ={0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff}; 
.................... result d7seg_display();
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxx Module 7 DOAN QUET xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... typedef struct 
.................... { 
....................   unsigned int8   led[8];  
.................... } S7SEG_STRUCT; 
.................... S7SEG_STRUCT    s7seg ={0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff}; 
.................... result s7seg_display();
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxx TRIAC-BUZZER xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... result buzzer_on(void);
.................... result buzzer_off(void);
.................... result triac_2_on(void);
.................... result triac_2_off(void);
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxx BASE FUNCTIONS xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... result system_init(void);
.................... result CHECK_MODULE();
.................... #endif
.................... 
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxx Module 32 LED don xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... result led32_display()
.................... {
....................      spi_write2(led32.ledx8[3]);spi_write2(led32.ledx8[2]);
*
000C0:  MOVF   F66,W
000C2:  MOVFF  0B,F66
000C6:  RRCF   F64,W
000C8:  BNC   00C6
000CA:  MOVF   F66,W
000CC:  MOVFF  0A,F66
000D0:  RRCF   F64,W
000D2:  BNC   00D0
....................      spi_write2(led32.ledx8[1]);spi_write2(led32.ledx8[0]);
000D4:  MOVF   F66,W
000D6:  MOVFF  09,F66
000DA:  RRCF   F64,W
000DC:  BNC   00DA
000DE:  MOVF   F66,W
000E0:  MOVFF  08,F66
000E4:  RRCF   F64,W
000E6:  BNC   00E4
....................      output_high(LED32_RCK); output_low(LED32_RCK);
000E8:  BCF    F95.5
000EA:  BSF    F8C.5
000EC:  BCF    F95.5
000EE:  BCF    F8C.5
....................      return OK;
000F0:  MOVLW  00
000F2:  MOVWF  01
000F4:  RETURN 0
.................... }
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxx Module 7 DOAN TT xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... result d7seg_display()
.................... {
....................       spi_write2(d7seg.led[4]);spi_write2(d7seg.led[5]);
000F6:  MOVF   F66,W
000F8:  MOVFF  10,F66
000FC:  RRCF   F64,W
000FE:  BNC   00FC
00100:  MOVF   F66,W
00102:  MOVFF  11,F66
00106:  RRCF   F64,W
00108:  BNC   0106
....................       spi_write2(d7seg.led[6]);spi_write2(d7seg.led[7]);
0010A:  MOVF   F66,W
0010C:  MOVFF  12,F66
00110:  RRCF   F64,W
00112:  BNC   0110
00114:  MOVF   F66,W
00116:  MOVFF  13,F66
0011A:  RRCF   F64,W
0011C:  BNC   011A
....................       spi_write2(d7seg.led[0]);spi_write2(d7seg.led[1]);
0011E:  MOVF   F66,W
00120:  MOVFF  0C,F66
00124:  RRCF   F64,W
00126:  BNC   0124
00128:  MOVF   F66,W
0012A:  MOVFF  0D,F66
0012E:  RRCF   F64,W
00130:  BNC   012E
....................       spi_write2(d7seg.led[2]);spi_write2(d7seg.led[3]);
00132:  MOVF   F66,W
00134:  MOVFF  0E,F66
00138:  RRCF   F64,W
0013A:  BNC   0138
0013C:  MOVF   F66,W
0013E:  MOVFF  0F,F66
00142:  RRCF   F64,W
00144:  BNC   0142
....................       output_high(D7SEG_RCK); output_low(D7SEG_RCK);
00146:  BCF    F95.7
00148:  BSF    F8C.7
0014A:  BCF    F95.7
0014C:  BCF    F8C.7
....................       delay_ms(8);
0014E:  MOVLW  08
00150:  MOVWF  2C
00152:  RCALL  0040
....................       return OK;
00154:  MOVLW  00
00156:  MOVWF  01
00158:  RETURN 0
.................... }
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxx Module 7 DOAN QUET xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... result s7seg_display()
.................... {    
....................       for(int8 n=0;n<8;n++)
0015A:  CLRF   2A
0015C:  MOVF   2A,W
0015E:  SUBLW  07
00160:  BNC   01B4
....................       {
....................             output_e(s7seg.led[n]); spi_write2(0x80>>n);
00162:  CLRF   03
00164:  MOVF   2A,W
00166:  ADDLW  14
00168:  MOVWF  FE9
0016A:  MOVLW  00
0016C:  ADDWFC 03,W
0016E:  MOVWF  FEA
00170:  MOVFF  FEF,F8D
00174:  CLRF   F96
00176:  MOVLW  80
00178:  MOVWF  2B
0017A:  MOVF   2A,W
0017C:  MOVWF  01
0017E:  BZ    0188
00180:  BCF    FD8.0
00182:  RRCF   2B,F
00184:  DECFSZ 01,F
00186:  BRA    0180
00188:  MOVF   F66,W
0018A:  MOVFF  2B,F66
0018E:  RRCF   F64,W
00190:  BNC   018E
....................             output_high(S7SEG_RCK); output_low(S7SEG_RCK);
00192:  BCF    F92.5
00194:  BSF    F89.5
00196:  BCF    F92.5
00198:  BCF    F89.5
....................             delay_ms(1);
0019A:  MOVLW  01
0019C:  MOVWF  2C
0019E:  RCALL  0040
....................             spi_write2(0);
001A0:  MOVF   F66,W
001A2:  CLRF   F66
001A4:  RRCF   F64,W
001A6:  BNC   01A4
....................             output_high(S7SEG_RCK); output_low(S7SEG_RCK);
001A8:  BCF    F92.5
001AA:  BSF    F89.5
001AC:  BCF    F92.5
001AE:  BCF    F89.5
001B0:  INCF   2A,F
001B2:  BRA    015C
....................       }
....................       return OK;
001B4:  MOVLW  00
001B6:  MOVWF  01
001B8:  GOTO   0202 (RETURN)
.................... }
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxx Module KEY4x4 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... unsigned int8 KEYREAD()
.................... {   const unsigned int8 mq[]={0xef,0xdf,0xbf,0x7f};
....................     for(int8 cot=0;cot<4;cot++)
*
0023A:  CLRF   2A
0023C:  MOVF   2A,W
0023E:  SUBLW  03
00240:  BNC   02DA
....................     {
....................         if(mq[cot]&0x80) output_float(pin_b7);
00242:  CLRF   03
00244:  MOVF   2A,W
00246:  RCALL  0028
00248:  ANDLW  80
0024A:  BZ    0250
0024C:  BSF    F93.7
0024E:  BRA    0254
....................         else             output_low(pin_b7);
00250:  BCF    F93.7
00252:  BCF    F8A.7
....................         if(mq[cot]&0x40) output_float(pin_b6);
00254:  CLRF   03
00256:  MOVF   2A,W
00258:  RCALL  0028
0025A:  ANDLW  40
0025C:  BZ    0262
0025E:  BSF    F93.6
00260:  BRA    0266
....................         else             output_low(pin_b6);
00262:  BCF    F93.6
00264:  BCF    F8A.6
....................         if(mq[cot]&0x20) output_float(pin_b5);
00266:  CLRF   03
00268:  MOVF   2A,W
0026A:  RCALL  0028
0026C:  ANDLW  20
0026E:  BZ    0274
00270:  BSF    F93.5
00272:  BRA    0278
....................         else             output_low(pin_b5);
00274:  BCF    F93.5
00276:  BCF    F8A.5
....................         if(mq[cot]&0x10) output_float(pin_b4);
00278:  CLRF   03
0027A:  MOVF   2A,W
0027C:  RCALL  0028
0027E:  ANDLW  10
00280:  BZ    0286
00282:  BSF    F93.4
00284:  BRA    028A
....................         else             output_low(pin_b4);
00286:  BCF    F93.4
00288:  BCF    F8A.4
....................         IF          (!INPUT(pin_b0))    return 0+cot*4;             
0028A:  BSF    F93.0
0028C:  BTFSC  F81.0
0028E:  BRA    029C
00290:  MOVF   2A,W
00292:  MULLW  04
00294:  MOVFF  FF3,01
00298:  BRA    02DE
0029A:  BRA    02D6
....................         ELSE    IF  (!INPUT(pin_b1))    return 1+cot*4;                  
0029C:  BSF    F93.1
0029E:  BTFSC  F81.1
002A0:  BRA    02B0
002A2:  MOVF   2A,W
002A4:  MULLW  04
002A6:  MOVF   FF3,W
002A8:  ADDLW  01
002AA:  MOVWF  01
002AC:  BRA    02DE
002AE:  BRA    02D6
....................         ELSE    IF  (!INPUT(pin_b2))    return 2+cot*4;               
002B0:  BSF    F93.2
002B2:  BTFSC  F81.2
002B4:  BRA    02C4
002B6:  MOVF   2A,W
002B8:  MULLW  04
002BA:  MOVF   FF3,W
002BC:  ADDLW  02
002BE:  MOVWF  01
002C0:  BRA    02DE
002C2:  BRA    02D6
....................         ELSE    IF  (!INPUT(pin_b3))    return 3+cot*4;  
002C4:  BSF    F93.3
002C6:  BTFSC  F81.3
002C8:  BRA    02D6
002CA:  MOVF   2A,W
002CC:  MULLW  04
002CE:  MOVF   FF3,W
002D0:  ADDLW  03
002D2:  MOVWF  01
002D4:  BRA    02DE
002D6:  INCF   2A,F
002D8:  BRA    023C
....................     }
....................     return 0xff;
002DA:  MOVLW  FF
002DC:  MOVWF  01
002DE:  GOTO   0456 (RETURN)
.................... }
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxx Module LCD xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... result write_lcd20x4(unsigned int8 lcd_signal, lcd_ins_hthi)
.................... {    
....................     output_bit(LCD_E,bit_test(lcd_signal,0));
....................     output_bit(LCD_RS,bit_test(lcd_signal,2));
....................     output_lcd(lcd_ins_hthi);
....................     return OK;
.................... }
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxx TRIAC-BUZZER xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... result buzzer_on(){output_high(BUZZER_PIN);return OK;}
.................... result buzzer_off(){ output_low(BUZZER_PIN);return OK;}
*
001BC:  BCF    F97.7
001BE:  BCF    F8E.7
001C0:  MOVLW  00
001C2:  MOVWF  01
001C4:  GOTO   0204 (RETURN)
.................... result triac_2_on(){output_high(TRIAC_PIN);return OK;}
.................... result triac_2_off(){output_low(TRIAC_PIN);return OK;}
001C8:  BCF    F97.6
001CA:  BCF    F8E.6
001CC:  MOVLW  00
001CE:  MOVWF  01
001D0:  GOTO   0206 (RETURN)
.................... result DCMOTOR_ENABLE()
.................... {
....................    setup_timer_2(t2_div_by_16,249,1);  // Cau hinh xung PWM T=0.8 ms, su dung PWM1
....................    setup_ccp1(ccp_pwm);  
....................    set_pwm1_duty((int16)0) ;
....................    output_low(DCMOTOR_IN1) ;
....................    return OK;
.................... }
.................... 
.................... result DCMOTOR_LOWLEVEL_CONTROL(signed int16 duty, int1 direct)
.................... {
....................      if(duty)
....................         if(direct){ output_high(DCMOTOR_IN1); set_pwm1_duty(1000-duty);  }
....................         else      { output_low(DCMOTOR_IN1) ; set_pwm1_duty(duty)     ;  }
....................      else         { output_low(DCMOTOR_IN1) ; set_pwm1_duty((int16)0) ;  }
....................      return OK;
.................... }
.................... result STEPMOTOR_ENABLE(){return OK;}
.................... result STEPMOTOR_LOWLEVEL_CONTROL(int1 mode, int8 step)
.................... {                                                                      
....................       const unsigned int8 Step_data[2][8]={0x01,0x03,0x02,0x06,0x04,0x0c,0x08,0x09,0x01,0x02,0x04,0x08,0x01,0x02,0x04,0x08};
....................       output_bit(STEPMOTOR_IN0, bit_test(step_data[mode][step],0));
....................       output_bit(STEPMOTOR_IN1, bit_test(step_data[mode][step],1));
....................       output_bit(STEPMOTOR_IN2, bit_test(step_data[mode][step],2));
....................       output_bit(STEPMOTOR_IN3, bit_test(step_data[mode][step],3));
....................       return OK;
.................... }
.................... 
.................... //xxxxxxxxxxxxxxxxxxxxxxxxxxxxx BOARD_INIT xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... result system_init()
.................... {
....................       CHECK_MODULE();
001D4:  BRA    0066
....................       set_tris_a(0xdf);
001D6:  MOVLW  DF
001D8:  MOVWF  F92
....................       set_tris_d(0x04);
001DA:  MOVLW  04
001DC:  MOVWF  F95
....................       set_tris_e(0);
001DE:  MOVLW  00
001E0:  MOVWF  F96
....................       set_tris_f(0);
001E2:  MOVWF  F97
....................       set_tris_g(0);
001E4:  MOVWF  F98
....................       set_tris_c(0xff);
001E6:  MOVLW  FF
001E8:  MOVWF  F94
....................       port_b_pullups(0xFF);
001EA:  BCF    FF1.7
....................       output_g(0);
001EC:  CLRF   F98
001EE:  CLRF   F8F
....................       output_high(pin_g0);
001F0:  BCF    F98.0
001F2:  BSF    F8F.0
....................       led32.ledx32=0;
001F4:  CLRF   0B
001F6:  CLRF   0A
001F8:  CLRF   09
001FA:  CLRF   08
....................       led32_display();
001FC:  RCALL  00C0
....................       d7seg_display();
001FE:  RCALL  00F6
....................       s7seg_display();
00200:  BRA    015A
....................       buzzer_off(); 
00202:  BRA    01BC
....................       triac_2_off();
00204:  BRA    01C8
....................       setup_timer_3(t3_internal|t3_div_by_8|T3_CCP2_TO_5);
00206:  MOVLW  BD
00208:  MOVWF  FB1
....................       return OK;
0020A:  MOVLW  00
0020C:  MOVWF  01
0020E:  GOTO   0680 (RETURN)
.................... }
.................... /*********************************** Check module ************************************************************/
.................... result CHECK_MODULE()
*
00066:  BSF    2A.0
.................... {
....................     int1 tt=1;
....................       unsigned int8 n;
....................       for(n=0;n<10;n++)
00068:  CLRF   2B
0006A:  MOVF   2B,W
0006C:  SUBLW  09
0006E:  BNC   0098
....................       {     output_bit(pin_d0,tt);
00070:  BTFSC  2A.0
00072:  BRA    0078
00074:  BCF    F8C.0
00076:  BRA    007A
00078:  BSF    F8C.0
0007A:  BCF    F95.0
....................             if(input(pin_d1) !=tt)break;
0007C:  BSF    F95.1
0007E:  MOVLW  00
00080:  BTFSC  F83.1
00082:  MOVLW  01
00084:  MOVWF  2D
00086:  MOVLW  00
00088:  BTFSC  2A.0
0008A:  MOVLW  01
0008C:  SUBWF  2D,W
0008E:  BTFSS  FD8.2
00090:  BRA    0098
....................             tt=!tt;
00092:  BTG    2A.0
00094:  INCF   2B,F
00096:  BRA    006A
....................       }
....................       if(n<10) while(true)
00098:  MOVF   2B,W
0009A:  SUBLW  09
0009C:  BNC   00B8
....................       {    output_d(0xff);
0009E:  CLRF   F95
000A0:  SETF   F8C
....................            output_b(0xff); delay_ms(10);
000A2:  CLRF   F93
000A4:  SETF   F8A
000A6:  MOVLW  0A
000A8:  MOVWF  2C
000AA:  RCALL  0040
....................            output_b(0); delay_ms(10);
000AC:  CLRF   F93
000AE:  CLRF   F8A
000B0:  MOVLW  0A
000B2:  MOVWF  2C
000B4:  RCALL  0040
000B6:  BRA    009E
....................       }
....................       return OK;
000B8:  MOVLW  00
000BA:  MOVWF  01
000BC:  GOTO   01D6 (RETURN)
.................... }
.................... #endif
.................... 
.................... #warning"Day la file mo phong, SV khong duoc nap tren board that"
.................... #endif
.................... #include <TV_LOWLEVER.C>
.................... #ifndef  __TV_LOWLEVER_C__
.................... #define  __TV_LOWLEVER_C__
.................... #include <TV_LOWLEVER.H>
.................... #ifndef  __TV_LOWLEVER_H__
.................... #define  __TV_LOWLEVER_H__
.................... unsigned int16 delay_start();
.................... unsigned int16 delay_stop(unsigned int16 t);
.................... result inputcd(int16 pin);
.................... #endif
.................... 
.................... /*********************************** Soft I2C ************************************************************/
.................... #if      BOARD == MOPHONG
.................... result soft_i2c_clk()
.................... {   
....................       output_high(soft_i2c_scl);
....................       DELAY_us(1);  
....................       output_low(soft_i2c_scl);
....................       return OK;
.................... }
.................... result soft_i2c_start()
.................... {
....................       output_high(soft_i2c_sda);
....................       output_high(soft_i2c_scl);
....................       delay_us(1);
....................       output_low(soft_i2c_sda);
....................       delay_us(1);
....................       output_low(soft_i2c_scl);   
....................       return OK;
.................... }
.................... result soft_i2c_stop()
.................... {
....................       output_low(soft_i2c_sda);
....................       output_high(soft_i2c_scl);
....................       delay_us(1);
....................       output_high(soft_i2c_sda);
....................       return OK;
.................... }
.................... result soft_i2c_write(unsigned int8 b)
.................... {
....................       unsigned int8 m;
....................       int1 ack;
....................       for(m=0x80;m>0;m>>=1)
....................       {
....................             output_bit( soft_i2c_sda,b&m);
....................             soft_i2c_clk();
....................       }
....................       output_float(soft_i2c_sda);
....................       output_high(soft_i2c_scl);  
....................       delay_us(1);
....................       ack = input(soft_i2c_sda);
....................       output_low(soft_i2c_scl);  
....................       return ack;
.................... }
.................... 
.................... unsigned int8 soft_i2c_read(int1 ack)
.................... { 
....................       unsigned int8 n,nhan=0;
....................       output_float(soft_i2c_sda);
....................       for(n=0x80;n>0;n>>=1)
....................       {      
....................             output_high(soft_i2c_scl);  
....................             delay_us(1);
....................             if(input(soft_i2c_sda))nhan=nhan|n;
....................             output_low(soft_i2c_scl);   
....................       }
....................       if(ack)  output_low(soft_i2c_sda);
....................       else     output_high(soft_i2c_sda); 
....................       soft_i2c_clk();
....................       output_high(soft_i2c_sda); 
....................       return nhan;
.................... }
.................... #else 
.................... void soft_i2c_clk()
.................... {    
....................       output_high(soft_i2c_scl);
....................       output_low(soft_i2c_scl);
.................... }
.................... void soft_i2c_start()
.................... {
....................       output_high(soft_i2c_sda);
....................       output_high(soft_i2c_scl);
....................       output_low(soft_i2c_sda);
....................       output_low(soft_i2c_scl);      
.................... }
.................... void soft_i2c_stop()
.................... {
....................       output_low(soft_i2c_scl);
....................       output_low(soft_i2c_sda);
....................       output_high(soft_i2c_scl);
....................       output_high(soft_i2c_sda);
.................... }
.................... result soft_i2c_write(unsigned int8 b)
.................... {
....................       unsigned int8 m,dem=0;
....................       for(m=0x80;m>0;m>>=1)
....................       {
....................             output_bit(soft_i2c_sda,b&m);
....................             soft_i2c_clk();
....................       }
....................      output_float(soft_i2c_sda);
....................      output_high(soft_i2c_scl);
....................      while(input(soft_i2c_sda)&(dem<5)){dem++; delay_us(1);}
....................      output_low(soft_i2c_scl);
....................      if(dem==5) return ERROR;
....................      else        return OK;
.................... }
.................... 
.................... unsigned int8 soft_i2c_read(int1 ack)
.................... { 
....................       unsigned int8 n,nhan=0;
....................       output_float(soft_i2c_sda);
....................       for(n=0x80;n>0;n>>=1)
....................       {    
....................             output_high(soft_i2c_scl);  
....................             if(input(soft_i2c_sda))nhan=nhan|n; 
....................             output_low(soft_i2c_scl);  
....................       } 
....................       output_bit(soft_i2c_sda,!ack);
....................       soft_i2c_clk();
....................       return nhan;
.................... }
.................... #endif
.................... /*********************************** Delay ************************************************************/
.................... unsigned int16 delay_start()
.................... {    
....................       delay.timeline += get_timer3() ;set_timer3(2);
*
00370:  MOVF   FB2,W
00372:  MOVFF  FB3,03
00376:  ADDWF  04,F
00378:  MOVF   FB3,W
0037A:  ADDWFC 05,F
0037C:  MOVLW  00
0037E:  ADDWFC 06,F
00380:  ADDWFC 07,F
00382:  CLRF   FB3
00384:  MOVLW  02
00386:  MOVWF  FB2
00388:  NOP   
....................       if(TIM3IF) delay.timeline +=65536;TIM3IF=0;
0038A:  BTFSS  FA1.1
0038C:  BRA    0396
0038E:  MOVLW  01
00390:  ADDWF  06,F
00392:  MOVLW  00
00394:  ADDWFC 07,F
00396:  BCF    FA1.1
....................       return delay.timeline/625;
00398:  BCF    FD8.1
0039A:  MOVFF  07,31
0039E:  MOVFF  06,30
003A2:  MOVFF  05,2F
003A6:  MOVFF  04,2E
003AA:  CLRF   35
003AC:  CLRF   34
003AE:  MOVLW  02
003B0:  MOVWF  33
003B2:  MOVLW  71
003B4:  MOVWF  32
003B6:  RCALL  02E2
003B8:  MOVFF  01,02
003BC:  MOVFF  00,01
003C0:  RETURN 0
.................... }
.................... 
.................... unsigned int16 delay_stop(unsigned int16 t)
.................... {    
....................       unsigned int16 tam;
....................       delay.timeline += get_timer3() ;set_timer3(2);
003C2:  MOVF   FB2,W
003C4:  MOVFF  FB3,03
003C8:  ADDWF  04,F
003CA:  MOVF   FB3,W
003CC:  ADDWFC 05,F
003CE:  MOVLW  00
003D0:  ADDWFC 06,F
003D2:  ADDWFC 07,F
003D4:  CLRF   FB3
003D6:  MOVLW  02
003D8:  MOVWF  FB2
003DA:  NOP   
....................       if(TIM3IF) delay.timeline +=65536;TIM3IF=0;
003DC:  BTFSS  FA1.1
003DE:  BRA    03E8
003E0:  MOVLW  01
003E2:  ADDWF  06,F
003E4:  MOVLW  00
003E6:  ADDWFC 07,F
003E8:  BCF    FA1.1
....................       tam = delay.timeline/625;
003EA:  BCF    FD8.1
003EC:  MOVFF  07,31
003F0:  MOVFF  06,30
003F4:  MOVFF  05,2F
003F8:  MOVFF  04,2E
003FC:  CLRF   35
003FE:  CLRF   34
00400:  MOVLW  02
00402:  MOVWF  33
00404:  MOVLW  71
00406:  MOVWF  32
00408:  RCALL  02E2
0040A:  MOVFF  01,2D
0040E:  MOVFF  00,2C
....................       if(t<=tam) return tam-t;
00412:  MOVF   2B,W
00414:  SUBWF  2D,W
00416:  BNC   0436
00418:  BNZ   0420
0041A:  MOVF   2A,W
0041C:  SUBWF  2C,W
0041E:  BNC   0436
00420:  MOVF   2A,W
00422:  SUBWF  2C,W
00424:  MOVWF  00
00426:  MOVF   2B,W
00428:  SUBWFB 2D,W
0042A:  MOVWF  03
0042C:  MOVFF  00,01
00430:  MOVWF  02
00432:  BRA    0452
00434:  BRA    0452
....................       else       return 0xffff-t + tam;
00436:  MOVLW  FF
00438:  BSF    FD8.0
0043A:  SUBFWB 2A,W
0043C:  MOVWF  2E
0043E:  MOVLW  FF
00440:  SUBFWB 2B,W
00442:  MOVWF  2F
00444:  MOVF   2C,W
00446:  ADDWF  2E,W
00448:  MOVWF  01
0044A:  MOVF   2D,W
0044C:  ADDWFC 2F,W
0044E:  MOVWF  03
00450:  MOVWF  02
00452:  RETURN 0
.................... }
.................... /*********************************** Button ************************************************************/
.................... result inputcd(int16 pin)
.................... {
....................       static unsigned int16 oldpin=0xffff;
....................       static unsigned int16 t; 
....................       static unsigned int8 step=0;
....................       output_float(pin);
....................       switch (step)
....................       {
....................           case 0:
....................                  if(input(pin)==0)
....................                   {
....................                         oldpin   = pin;
....................                         t        = delay_start();
....................                         step     = 1;
....................                   }
....................                  break;
....................            case 1:
....................                  if(input(oldpin))step = 0;
....................                  else if((pin==oldpin)&&(delay_stop(t)>=30))
....................                    {
....................                       t    = delay_start();
....................                       step = 2;
....................                       return OK;
....................                    }
....................                  break;
....................             case 2:
....................                  if(input(oldpin))step = 0;
....................                  else if((pin==oldpin)&&(delay_stop(t)>=500))
....................                    {
....................                        t        = delay_start();
....................                        step     = 3;
....................                    } 
....................                  break;
....................             case 3:
....................                    if(input(oldpin))step = 0; 
....................                    else if((pin==oldpin)&&(delay_stop(t)>=100))
....................                        {
....................                           t  = delay_start();
....................                           return OK;
....................                        }
....................                  break;
....................       }   
....................       return BUSY; 
.................... }
.................... #endif
.................... 
.................... #ignore_warnings 202
.................... #endif
.................... 
.................... #include<tv_key4x4.c> 
.................... #ifndef  __TV_KEY4x4_C__
.................... #define  __TV_KEY4x4_C__
.................... #include<tv_key4x4.h>
.................... #ifndef  __TV_KEY4x4_H__
.................... #define  __TV_KEY4x4_H__
.................... typedef struct
.................... {
....................       unsigned int8 key;
.................... }KEY4x4_STRUCT;
.................... KEY4x4_STRUCT  key4x4;
.................... result key4x4_read(void);
.................... #endif
.................... 
.................... result key4x4_read()
.................... {      
....................          static unsigned int8  step=0;
....................          static unsigned int16 t;
....................          key4x4.key = KEYREAD();
00454:  BRA    023A
00456:  MOVFF  01,21
....................          switch (step)
0045A:  MOVF   22,W
0045C:  ADDLW  FC
0045E:  BTFSC  FD8.0
00460:  BRA    0526
00462:  ADDLW  04
00464:  GOTO   052E
....................          {
....................              case 0:
....................                    if( key4x4.key!=0xff)
00468:  INCFSZ 21,W
0046A:  BRA    046E
0046C:  BRA    047C
....................                       {     t   = delay_start();
0046E:  RCALL  0370
00470:  MOVFF  02,24
00474:  MOVFF  01,23
....................                             step=1;
00478:  MOVLW  01
0047A:  MOVWF  22
....................                       } 
....................                     break;
0047C:  BRA    0526
....................               case 1:
....................                     if(key4x4.key==0xff)step =0;
0047E:  INCFSZ 21,W
00480:  BRA    0486
00482:  CLRF   22
00484:  BRA    04B6
....................                     else if(delay_stop(t)>=30)
00486:  MOVFF  24,2B
0048A:  MOVFF  23,2A
0048E:  RCALL  03C2
00490:  MOVFF  02,2B
00494:  MOVFF  01,2A
00498:  MOVF   2B,F
0049A:  BNZ   04A2
0049C:  MOVF   2A,W
0049E:  SUBLW  1D
004A0:  BC    04B6
....................                     {   step = 2;
004A2:  MOVLW  02
004A4:  MOVWF  22
....................                         t    = delay_start(); 
004A6:  RCALL  0370
004A8:  MOVFF  02,24
004AC:  MOVFF  01,23
....................                         return OK;
004B0:  MOVLW  00
004B2:  MOVWF  01
004B4:  BRA    052A
....................                     }
....................                     break; 
004B6:  BRA    0526
....................               case 2:
....................                     if(key4x4.key==0xff)step =0;
004B8:  INCFSZ 21,W
004BA:  BRA    04C0
004BC:  CLRF   22
004BE:  BRA    04F0
....................                     else if(delay_stop(t)>=500)
004C0:  MOVFF  24,2B
004C4:  MOVFF  23,2A
004C8:  RCALL  03C2
004CA:  MOVFF  02,2B
004CE:  MOVFF  01,2A
004D2:  MOVF   02,W
004D4:  SUBLW  00
004D6:  BC    04F0
004D8:  XORLW  FF
004DA:  BNZ   04E2
004DC:  MOVF   2A,W
004DE:  SUBLW  F3
004E0:  BC    04F0
....................                        {
....................                            t    = delay_start(); 
004E2:  RCALL  0370
004E4:  MOVFF  02,24
004E8:  MOVFF  01,23
....................                            step = 3;
004EC:  MOVLW  03
004EE:  MOVWF  22
....................                        } 
....................                     break;
004F0:  BRA    0526
....................               case 3:
....................                     if(key4x4.key==0xff)step =0;
004F2:  INCFSZ 21,W
004F4:  BRA    04FA
004F6:  CLRF   22
004F8:  BRA    0526
....................                     else if(delay_stop(t)>=100)
004FA:  MOVFF  24,2B
004FE:  MOVFF  23,2A
00502:  RCALL  03C2
00504:  MOVFF  02,2B
00508:  MOVFF  01,2A
0050C:  MOVF   2B,F
0050E:  BNZ   0516
00510:  MOVF   2A,W
00512:  SUBLW  63
00514:  BC    0526
....................                       {
....................                          t    = delay_start(); 
00516:  RCALL  0370
00518:  MOVFF  02,24
0051C:  MOVFF  01,23
....................                          return OK;
00520:  MOVLW  00
00522:  MOVWF  01
00524:  BRA    052A
....................                       }
....................                      break; 
....................          }
....................          return BUSY;
00526:  MOVLW  02
00528:  MOVWF  01
0052A:  GOTO   0558 (RETURN)
.................... }
.................... #endif
.................... 
.................... signed int8 i;
.................... unsigned int16 n;
.................... unsigned int8 dem=0;
.................... unsigned int1 tt=0;
.................... void quetphim_xuly()
.................... {
....................       if(key4x4_read()==OK)
*
00556:  BRA    0454
00558:  MOVF   01,F
0055A:  BNZ   05E6
....................       {     //1. Nhan cac phim tu 0 den 12 de bat hoac tat cac LED tu 0-12
....................             if(key4x4.key<13) led32.ledx16[0]^=((int16)0x01<<key4x4.key);
0055C:  MOVF   21,W
0055E:  SUBLW  0C
00560:  BNC   0580
00562:  CLRF   03
00564:  MOVLW  01
00566:  MOVWF  02
00568:  MOVF   21,W
0056A:  MOVWF  00
0056C:  BZ    0578
0056E:  BCF    FD8.0
00570:  RLCF   02,F
00572:  RLCF   03,F
00574:  DECFSZ 00,F
00576:  BRA    056E
00578:  MOVF   02,W
0057A:  XORWF  08,F
0057C:  MOVF   03,W
0057E:  XORWF  09,F
....................             led32_display();
00580:  RCALL  00C0
....................             
....................             //2. Nhan phim 15 de cho phep 16 LED tan cung ben trai sang dan lien tuc
....................             if(key4x4.key==15)tt=1;
00582:  MOVF   21,W
00584:  SUBLW  0F
00586:  BNZ   058A
00588:  BSF    29.0
....................             
....................             //3. Nhan giu phim 13 de tang bien dem  va hien thi LED 7 doan
....................             if(key4x4.key==13)dem++;   
0058A:  MOVF   21,W
0058C:  SUBLW  0D
0058E:  BNZ   0592
00590:  INCF   28,F
....................             
....................             //4. Nhan giu phim 14 de giam bien dem  va hien thi LED 7 doan
....................             if(key4x4.key==14)dem--;
00592:  MOVF   21,W
00594:  SUBLW  0E
00596:  BNZ   059A
00598:  DECF   28,F
....................             d7seg.led[2] = m7d[dem/100%10];      
0059A:  MOVFF  28,2B
0059E:  MOVLW  64
005A0:  MOVWF  2C
005A2:  RCALL  0212
005A4:  MOVFF  01,2B
005A8:  MOVLW  0A
005AA:  MOVWF  2C
005AC:  RCALL  0212
005AE:  CLRF   03
005B0:  MOVF   00,W
005B2:  RCALL  0004
005B4:  MOVWF  0E
....................             d7seg.led[1] = m7d[dem/10%10];        
005B6:  MOVFF  28,2B
005BA:  MOVLW  0A
005BC:  MOVWF  2C
005BE:  RCALL  0212
005C0:  MOVFF  01,2B
005C4:  MOVLW  0A
005C6:  MOVWF  2C
005C8:  RCALL  0212
005CA:  CLRF   03
005CC:  MOVF   00,W
005CE:  RCALL  0004
005D0:  MOVWF  0D
....................             d7seg.led[0] = m7d[dem/1%10];       
005D2:  MOVFF  28,2B
005D6:  MOVLW  0A
005D8:  MOVWF  2C
005DA:  RCALL  0212
005DC:  CLRF   03
005DE:  MOVF   00,W
005E0:  RCALL  0004
005E2:  MOVWF  0C
....................             d7seg_display();
005E4:  RCALL  00F6
....................       }
005E6:  RETURN 0
.................... }
.................... void sangdan16led()                
.................... {    
....................      for(i=16;i>=0;i--)
005E8:  MOVLW  10
005EA:  MOVWF  25
005EC:  BTFSC  25.7
005EE:  BRA    0626
....................       {
....................             led32.ledx16[1]=0xffff>>i;
005F0:  SETF   0B
005F2:  SETF   0A
005F4:  MOVF   25,W
005F6:  MOVWF  00
005F8:  BZ    0604
005FA:  BCF    FD8.0
005FC:  RRCF   0B,F
005FE:  RRCF   0A,F
00600:  DECFSZ 00,F
00602:  BRA    05FA
....................             led32_display(); 
00604:  RCALL  00C0
....................             // delay_ms(200);        // bo delay lau thay bang chuong trinh quet va xu ly phim nhieu lan
....................             for(n=0;n<1000;n++) quetphim_xuly();
00606:  CLRF   27
00608:  CLRF   26
0060A:  MOVF   27,W
0060C:  SUBLW  03
0060E:  BNC   0622
00610:  BNZ   0618
00612:  MOVF   26,W
00614:  SUBLW  E7
00616:  BNC   0622
00618:  RCALL  0556
0061A:  INCF   26,F
0061C:  BTFSC  FD8.2
0061E:  INCF   27,F
00620:  BRA    060A
00622:  DECF   25,F
00624:  BRA    05EC
....................       }
00626:  GOTO   06D4 (RETURN)
.................... }
.................... void main()
0062A:  CLRF   FF8
0062C:  BCF    FD0.7
0062E:  BCF    F63.5
00630:  MOVLW  00
00632:  MOVWF  F64
00634:  MOVLW  20
00636:  MOVWF  F63
00638:  BCF    F95.4
0063A:  BSF    F95.5
0063C:  BCF    F95.6
0063E:  CLRF   28
00640:  BCF    29.0
00642:  MOVF   FC1,W
00644:  ANDLW  C0
00646:  IORLW  0F
00648:  MOVWF  FC1
0064A:  MOVLW  07
0064C:  MOVWF  FB4
0064E:  SETF   0C
00650:  SETF   0D
00652:  SETF   0E
00654:  SETF   0F
00656:  SETF   10
00658:  SETF   11
0065A:  SETF   12
0065C:  SETF   13
0065E:  SETF   14
00660:  SETF   15
00662:  SETF   16
00664:  SETF   17
00666:  SETF   18
00668:  SETF   19
0066A:  SETF   1A
0066C:  SETF   1B
0066E:  SETF   1C
00670:  SETF   1D
00672:  CLRF   1E
00674:  CLRF   1F
00676:  CLRF   20
00678:  CLRF   22
0067A:  CLRF   23
0067C:  CLRF   24
.................... {
....................       system_init();  
0067E:  BRA    01D4
....................       d7seg.led[2] = m7d[dem/100%10];      
00680:  MOVFF  28,2B
00684:  MOVLW  64
00686:  MOVWF  2C
00688:  RCALL  0212
0068A:  MOVFF  01,2B
0068E:  MOVLW  0A
00690:  MOVWF  2C
00692:  RCALL  0212
00694:  CLRF   03
00696:  MOVF   00,W
00698:  RCALL  0004
0069A:  MOVWF  0E
....................       d7seg.led[1] = m7d[dem/10%10];        
0069C:  MOVFF  28,2B
006A0:  MOVLW  0A
006A2:  MOVWF  2C
006A4:  RCALL  0212
006A6:  MOVFF  01,2B
006AA:  MOVLW  0A
006AC:  MOVWF  2C
006AE:  RCALL  0212
006B0:  CLRF   03
006B2:  MOVF   00,W
006B4:  RCALL  0004
006B6:  MOVWF  0D
....................       d7seg.led[0] = m7d[dem/1%10];       
006B8:  MOVFF  28,2B
006BC:  MOVLW  0A
006BE:  MOVWF  2C
006C0:  RCALL  0212
006C2:  CLRF   03
006C4:  MOVF   00,W
006C6:  RCALL  0004
006C8:  MOVWF  0C
....................       d7seg_display();
006CA:  RCALL  00F6
....................       
....................       while(true)
....................       {     
....................             quetphim_xuly();
006CC:  RCALL  0556
....................             //2. Nhan phim 15 de cho phep 16 LED tan cung ben trai sang dan lien tuc
....................             if(tt==1)   
006CE:  BTFSS  29.0
006D0:  BRA    06D4
....................             {
....................                sangdan16led() ;
006D2:  BRA    05E8
....................             }
006D4:  BRA    06CC
....................       }
.................... }
006D6:  SLEEP 

Configuration Fuses:
   Word  1: C200   HS FCMEN IESO
   Word  2: 1E1E   PUT BROWNOUT BORV21 NOWDT WDT32768
   Word  3: 85F3   CCP2C1 LPT1OSC MCLR
   Word  4: 00B1   STVREN NOLVP NOXINST NODEBUG
   Word  5: C0FF   NOPROTECT NOCPB NOCPD
   Word  6: E0FF   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 40FF   NOEBTR NOEBTRB
